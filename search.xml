<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS代码规范</title>
      <link href="/2017/07/25/iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2017/07/25/iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h2 id="一-XCode设置"><a href="#一-XCode设置" class="headerlink" title="一. XCode设置"></a>一. XCode设置</h2><ol><li>使用空格而不是制表符 <code>Tab</code>，不要在工程里使用 <code>Tab</code> 键，使用空格来进行缩进。<br> 在 <code>Xcode &gt; Preferences &gt; Text Editing</code> 将 <code>Tab</code> 和自动缩进都设置为 4 个空格。  </li><li>同样的，在 <code>Xcode &gt; Preferences &gt; Text Editing &gt; Page guide at column</code>: 中将最大行长设置为 100 ，过长的一行代码将会导致可读性问题。</li></ol><h2 id="二-整体风格："><a href="#二-整体风格：" class="headerlink" title="二.整体风格："></a>二.整体风格：</h2><ol><li>前缀：解决<code>OC</code>没有命名空间的问题。命名类、协议、常量、枚举、宏定义和<code>typedef</code>结构体时使用前缀</li><li>命名采用英文单词或其组合，采用大小驼峰命名法，应直观可拼读，最好望文知义，切忌使用汉语拼音来命名</li><li>禁止使用连续的下划线（<code>variable_name</code> 与 <code>ariable__name</code> 很难区分）</li><li><p>通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通知的命名范式是：</span><br><span class="line"></span><br><span class="line">[ 触发通知的类名 ] + [Did | Will] + [ 动作 ] + Notification</span><br><span class="line">UIApplicationDidEnterBackgroundNotification</span><br><span class="line">UIApplicationWillEnterForegroundNotification</span><br></pre></td></tr></table></figure></li><li><p><code>if</code>条件语句只有一行代码，不得省略<code>{}</code>，只有当条件语句和执行代码一行时才能省略（参考运算第7点）</p></li><li><code>@public</code> 和 <code>@private</code> 标记符应该以一个空格来进行缩进</li><li>建议加载<code>xib</code>，<code>xib</code>名称用<code>NSStringFromClass()</code>，避免书写错误</li><li>使用第三方框架，尽量不要更改内部文件，而应该再次封装，个性定制</li><li>删除所有无用代码（不用的代码直接删除，而不是注释掉）</li><li>空白行不要留空格（代码review是会显示成红色）</li></ol><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><ol><li>全部大写，单词间用 <code>_</code> 分隔 (<code>#define THIS_IS_AN_MACRO @&quot;THIS_IS_AN_MACRO&quot;</code>)</li><li>以字母 <code>k</code> 开头，后面遵循大驼峰命名 (<code>#define kWidth self.frame.size.width</code>)</li><li>不要使用 <code>#define</code> 宏来定义常量，因为如果使用宏定义, 一来宏可能被重定义. 二来引用不同的文件可能会导致宏的不同</li></ol><h3 id="运算相关"><a href="#运算相关" class="headerlink" title="运算相关"></a>运算相关</h3><ol><li>二元运算符和参数之间要有一个空格，如赋值号 <code>=</code> 左右各留一个空格</li><li>一元运算符和参数之间不放置空格，比如 <code>!</code>非运算符，<code>&amp;</code>按位与，<code>|</code>按位或</li><li>强制类型转换和参数之间不放置空格</li><li>浮点型变量不能用<code>==</code>或<code>！=</code>比较，无论是<code>float</code>类型还是<code>double</code>类型的变量，都有精度限制。<br> 所以一定要避免将浮点变量用<code>==</code>或<code>!=</code>与数字比较，应该转化成<code>&gt;=</code>或<code>&lt;=</code>形式</li><li><code>BOOL</code> 在 <code>Objective-C</code> 中被定义为 <code>signed char</code> 类型，这意味着一个 <code>BOOL</code> 类型的变量不仅仅可以表示 <code>YES(1)</code> 和 <code>NO(0)</code> 两个值，所以永远不要将 <code>BOOL</code> 类型变量直接和 <code>YES</code> 比较</li><li><p>判断<code>if</code>书写方式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">//建议这样写</span><br><span class="line">if (indexPath.row == 0) return 44;</span><br><span class="line">if (indexPath.row == 1) return 80;</span><br><span class="line">if (indexPath.row == 2) return 50;</span><br><span class="line">return 44;</span><br><span class="line"></span><br><span class="line">//而不是</span><br><span class="line">if (indexPath.row == 0) &#123;</span><br><span class="line">return 44;</span><br><span class="line">&#125; else if (indexPath.row == 1) &#123;</span><br><span class="line">        return 80;</span><br><span class="line">&#125; else if (indexPath.row == 2) &#123;</span><br><span class="line">        return 50;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        return 44;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ol><li><p>用<code>@[]</code>构建<code>NSArray</code>，用<code>@{}</code>构建<code>NSDictionary</code><br> 如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正确，在语法糖的 &quot;[]&quot; 或者 &quot;&#123;&#125;&quot; 两端留有空格</span><br><span class="line">NSArray *array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];</span><br><span class="line">NSDictionary *dict = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;</span><br><span class="line"></span><br><span class="line">// 不正确，不留有空格降低了可读性</span><br><span class="line">NSArray* array = @[[foo description], [bar description]];</span><br><span class="line">NSDictionary* dict = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;;</span><br></pre></td></tr></table></figure><p> 如果构造代码不写在一行内，构造元素需要使用两个空格来进行缩进，右括号 <code>]</code> 或者 <code>}</code> 写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐。<br> 构造字典时，字典的 <code>Key</code> 和 <code>Value</code> 与中间的冒号 <code>:</code> 都要留有一个空格，多行书写时，也可以将 <code>Value</code> 对齐</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//正确，冒号&apos;:&apos;前后留有一个空格</span><br><span class="line">NSDictionary *option1 = @&#123;</span><br><span class="line">NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//正确，按照Value来对齐</span><br><span class="line">NSDictionary *option2 = @&#123;</span><br><span class="line">NSFontAttributeName :            [NSFont fontWithName:@&quot;Arial&quot; size:12],</span><br><span class="line">NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用带有 <code>@</code> 符号的语法糖来生成<code>NSNumber</code> 对象能使代码更简洁：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *fortyTwo = @42;</span><br><span class="line">NSNumber *piOverTwo = @(M_PI / 2);</span><br><span class="line">enum &#123;</span><br><span class="line">kMyEnum = 2;</span><br><span class="line">&#125;;</span><br><span class="line">NSNumber *myEnum = @(kMyEnum);</span><br></pre></td></tr></table></figure></li></ol><h2 id="三-变量相关："><a href="#三-变量相关：" class="headerlink" title="三.变量相关："></a>三.变量相关：</h2><ol><li>类属性，临时变量采用小驼峰命名（<code>firstName</code>）；</li><li>指针<code>*</code>的位置，挨着变量名（<code>NSString *varName</code>）</li><li>局部变量不要与全局变量重名</li><li>成员变量使用<code>_</code>作为前缀，（<code>NSDictionary *_userInfo</code>）</li><li><p>使用 <code>const</code> 定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const CGFloat kTableViewCellHeight = 50.0f;</span><br><span class="line">const NSInteger kTableViewRows = 5;</span><br></pre></td></tr></table></figure></li><li><p>对于拥有<code>Mutable</code>子类型的对象(e.g. <code>NSString</code>, <code>NSArray</code>, <code>NSDictionary</code>)一定要定义成<code>copy</code>属性</p></li><li>如果是内部使用的属性, 那么就定义成私有的属性(定义到<code>.m</code>的<code>class extension</code>里面)</li><li>尽量不要暴露<code>mutable</code>类型的对象在<code>public interface</code>, 建议在<code>.h</code>定义一个<code>Inmutable</code>类型的属性, 然后在<code>.m</code>的<code>get</code>函数里面返回一个内部定义的<code>mutable</code>变量</li><li>尽量不要使用死值，死值每次修改的时候容易被遗忘，地方多了找起来就悲剧了。而且定义成枚举或者<code>static</code>可以让错误发生在编译阶段。另外仅仅看到一个数字，完全不知道这个数字代表的意义</li><li><p>如果声明的属性，只想使用的<code>get</code>方法，不使用<code>set</code>方法，并且不想让外界更改这个属性的值，那么建议在括号里面加<code>readonly</code></p></li><li><p>给属性命名时建议采用修饰+类型的方式。以免产生歧义，比如<code>title</code> (这个到底是个<code>NSString</code>还是<code>UILabel</code>?)。同样的，<code>label</code> 我知道你是个<code>UILabel</code>，但是我不知道它是用来做什么的呀？）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//正确的命名方式为</span><br><span class="line">titleLabel    //表示标题的label,  是UILabel类型</span><br><span class="line">confirmButton //表示确认的button, 是UIButton类型</span><br></pre></td></tr></table></figure></li><li><p>一个类的 <code>Delegate</code> 对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的 <code>Delegate</code> 属性要设置为弱引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;XXXX&gt; delegate;</span><br></pre></td></tr></table></figure></li><li><p>如果属性是<code>BOOL</code>类型，建议在括号中重写<code>get</code>方法名称，以提高可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly,getter=isKeyWindow) BOOL keyWindow;</span><br></pre></td></tr></table></figure></li></ol><h2 id="四-函数相关："><a href="#四-函数相关：" class="headerlink" title="四.函数相关："></a>四.函数相关：</h2><ol><li>不要使用 <code>new</code> 方法创建对象</li><li>在每个方法的定义前留白一行，也就是在方法和方法之间留空一行</li><li>避免函数有太多的参数，这样容易把参数顺序搞错，调用不方便，若较多，可把参数定义成一个结构体，把结构体的指针当成参数传入</li><li>参数过多时，每个参数占用一行，以冒号对齐</li><li>函数长度不要超过50行，小函数比大函数可读性更强。函数的参数不宜过多，零元函数最好，一元函数也不错，高于三元的函数需重构</li><li><code>{</code>可写在方法末尾（加空格），也可另起一行</li><li>私有方法在方法名前加<code>p_</code></li><li>使用 <code>#pragma mark -</code> 方式对类的方法进行分组</li><li><code>dealloc</code>函数放在最前面</li><li>保持公共<code>API</code>的简洁性</li><li>不要用点分语法来调用方法，只用来访问属性。这样是为了防止代码可读性问题</li><li>函数调用的格式和声明格式一样。</li><li><p>如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加<code>get</code>或者其他的动词前缀<br>为什么 <code>Objective-C</code> 中不适用 <code>get</code> 前缀来表示属性获取方法？因为 <code>get</code> 在 <code>Objective-C</code> 中通常只用来表示从函数指针返回值的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 三个参数都是作为函数的返回值来使用的，这样的函数名可以使用 &quot;get&quot; 前缀</span><br><span class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br></pre></td></tr></table></figure></li><li><p>函数命名原则（遵循<code>Apple</code>风格）：小驼峰，尽量清晰明了，采用单词全拼，冒号对齐；尽量做到不需要注释也能了解其作用<br><code>-</code> 和 <code>(void)</code> 之间加空格，方法名和第一个参数之间不留空格，参数之前的关键字要明确(<code>middleName</code>,<code>lastName</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveMyFirstName:(NSString *)firstName</span><br><span class="line">             middleName:(NSString *)middleName</span><br><span class="line">               lastName:(NSString *)lastName;</span><br></pre></td></tr></table></figure></li><li><p>m文件函数实现：第一个大括号换行,其他使用场景(<code>if</code> <code>while</code> <code>else</code>)等左括号跟在第一行后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveMyFirstName:(NSString *)firstName</span><br><span class="line">             middleName:(NSString *)middleName</span><br><span class="line">               lastName:(NSString *)lastName</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">if (1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>黄金路径，使用条件语句时，左手的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//应该：</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">if (![someOther boolValue]) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//Do something important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不应该：</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">if ([someOther boolValue]) &#123;</span><br><span class="line">//Do something important</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在继承中，凡是要求子类重写父类的方法必须先调用父类的这个方法进行初始化操作;<br>建议:父类的方法名后面加上 <code>NS_REQUIRES_SUPER</code> ; 子类重写这个方法就会自动警告提示要调用这个 <code>super</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注意:父类中的方法加`NS_REQUIRES_SUPER`,子类重写才有警告提示</span><br><span class="line">- (void)prepare NS_REQUIRES_SUPER;</span><br></pre></td></tr></table></figure></li></ol><h2 id="五-UI布局相关："><a href="#五-UI布局相关：" class="headerlink" title="五. UI布局相关："></a>五. UI布局相关：</h2><ol><li>尽量使用<code>Storyboard</code> + 自动布局</li><li>代码布局时尽量使用相对布局，比如使用子<code>View</code>在父<code>View</code>中的相对位置</li><li>与主题颜色相关的控件添加引用在代码中设置，方便同意替换主题色</li></ol><h2 id="六-类，协议相关："><a href="#六-类，协议相关：" class="headerlink" title="六. 类，协议相关："></a>六. 类，协议相关：</h2><ol><li>类采用前缀加大驼峰命名规则（<code>SSCPersonViewController</code>）;</li><li>协议加<code>delegate</code>或其他比较明确能看出是协议的后缀（<code>delegate</code>，<code>protocol</code>，<code>DataSource</code>等）</li><li>协议中的方法遵循<code>Apple</code>系统风格，参考（<code>UITableViewDelegate</code>，<code>UITableViewDataSource</code>的函数风格）</li><li>对外暴露的接口和属性放头文件，不暴露的放在<code>m</code>文件；</li><li>给分类扩充方法，建议加上前缀，同理跟分类添加属性（利用运行时），建议加前缀</li><li><p>一个委托方法的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为 <code>sender</code> 的参数：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 第一个关键词为触发委托的类名</span><br><span class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br><span class="line"></span><br><span class="line">// 当只有一个 &quot;sender&quot; 参数时可以省略类名</span><br><span class="line">- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</span><br><span class="line"></span><br><span class="line">//根据委托方法触发的时机和目的，使用 should,will,did 等关键词</span><br><span class="line">- (void)browserDidScroll:(NSBrowser *)sender;</span><br><span class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window; 、</span><br><span class="line">- (BOOL)windowShouldClose:(id)sender;</span><br></pre></td></tr></table></figure></li><li><p>类型标识符、代理名称、尖括号间不留空格，该规则同样适用于<code>delegate</code>申明</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>如果类申明中包含多个    protocal    ，每个    protocal`占用一行，缩进 4 个字符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface SSCOrderViewController ()&lt;</span><br><span class="line">UITableViewDelegate,</span><br><span class="line">UITableViewDataSource,</span><br><span class="line">SSCOrderEstimateCellDelegate</span><br><span class="line">&gt; &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="七-Block："><a href="#七-Block：" class="headerlink" title="七. Block："></a>七. Block：</h2><ol><li>注意必要时使用<code>WEAKSELF</code>和<code>STRONGSELF</code>，避免造成循环引用，以及野指针（常见于访问实例变量，<code>NSTimer</code>等场景）</li><li>较短的 <code>block</code> 可以写在一行内。</li><li>如果分行显示的话， <code>block</code> 的右括号 <code>}</code> 应该和调用 <code>block</code> 那行代码的第一个非空字符对齐。</li><li><code>block</code> 内的代码采用 4 个空格 的缩进。</li><li>如果 <code>block</code> 过于庞大，应该单独声明成一个变量来使用。</li><li><p><code>^</code> 和 <code>(</code> 之间， <code>^</code> 和 <code>{</code> 之间都没有空格，参数列表的右括号 <code>)</code> 和 <code>{</code> 之间有一个空格</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 较短的 block 写在一行内</span><br><span class="line">[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];</span><br><span class="line"></span><br><span class="line">// 分行书写的 block ，内部使用 4 空格缩进</span><br><span class="line">[operation setCompletionBlock:^&#123;</span><br><span class="line">[self.delegate newDataAvailable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 使用 C 语言 API 调用的 block 遵循同样的书写规则</span><br><span class="line">dispatch_async(_fileIOQueue, ^&#123;</span><br><span class="line">NSString* path = [self sessionFilePath];</span><br><span class="line">if (path) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 较长的 block 关键字可以缩进后在新行书写，注意 block 的右括号 &apos;&#125;&apos; 和调用 block 那行代码的第一个非空字符对齐</span><br><span class="line">[[SessionService sharedService]</span><br><span class="line">loadWindowWithCompletionBlock:^(SessionWindow *window) &#123;</span><br><span class="line">if (window) &#123;</span><br><span class="line">[self windowDidLoad:window];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self errorLoadingWindow];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 较长的 block 参数列表同样可以缩进后在新行书写</span><br><span class="line">[[SessionService sharedService]</span><br><span class="line">loadWindowWithCompletionBlock:</span><br><span class="line">^(SessionWindow *window) &#123;</span><br><span class="line">if (window) &#123;</span><br><span class="line">[self windowDidLoad:window];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self errorLoadingWindow];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 庞大的 block 应该单独定义成变量使用</span><br><span class="line">void (^largeBlock)(void) = ^&#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br><span class="line">[_operationQueue addOperationWithBlock:largeBlock];</span><br><span class="line"></span><br><span class="line">// 在一个调用中使用多个 block ，注意到他们不是像函数那样通过 &apos;:&apos; 对齐的，而是同时进行了 4 个空格的缩进</span><br><span class="line">[myObject doSomethingWith:arg1</span><br><span class="line">firstBlock:^(Foo *a) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">secondBlock:^(Bar *b) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ol><h2 id="八-单词简写"><a href="#八-单词简写" class="headerlink" title="八. 单词简写"></a>八. 单词简写</h2><p>不要使用单词的简写，拼写出完整的单词：  </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 清晰</span><br><span class="line">destinationSelection</span><br><span class="line">setBackgroundColor:</span><br><span class="line">// 不清晰，不要使用简写</span><br><span class="line">destSel</span><br><span class="line">setBkgdColor:</span><br></pre></td></tr></table></figure></code></pre><p>然而，有部分单词简写在 <code>Objective-C</code> 编码过程中是非常常用的，以至于成为了一种规范，这些简写可以在代码中直接使用  </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">alloc == Allocate</span><br><span class="line">max == Maximum</span><br><span class="line">alt == Alternate</span><br><span class="line">min == Minimum</span><br><span class="line">app == Application</span><br><span class="line">msg == Message</span><br><span class="line">calc == Calculate</span><br><span class="line">nib == Interface Builder archive</span><br><span class="line">dealloc == Deallocate</span><br><span class="line">pboard == Pasteboard</span><br><span class="line">func == Function</span><br><span class="line">rect == Rectangle</span><br><span class="line">horiz == Horizontal</span><br><span class="line">Rep == Representation (used in class name such as NSBitmapImageRep).</span><br><span class="line">info == Information</span><br><span class="line">temp == Temporary</span><br><span class="line">init == Initialize</span><br><span class="line">vert == Vertical</span><br><span class="line">int == Integer</span><br><span class="line">btn == button</span><br><span class="line">txf == textField</span><br><span class="line">dict == dictionary</span><br></pre></td></tr></table></figure></code></pre><h2 id="九-注释"><a href="#九-注释" class="headerlink" title="九. 注释"></a>九. 注释</h2><ol><li>方法头部应进行注释，列出：函数的功能、输入参数、输出参数、返回值、修改信息等</li><li>全局变量要有详细的注释，包括对其功能、取值范围等说明</li><li>定义在头文件里的接口方法、属性必须要有注释</li><li><p>每个文件都必须写文件注释，文件注释通常包含：文件所在模块、作者信息、历史版本信息、版权信息、文件包含的内容，作用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">一段良好文件注释的栗子：</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">Copyright (C), 2011-2013, Andrew Min Chang</span><br><span class="line">File name: AMCCommonLib.h</span><br><span class="line">Author: Andrew Chang (Zhang Min)</span><br><span class="line">E-mail: LaplaceZhang@126.com</span><br><span class="line">Description:</span><br><span class="line">This file provide some covenient tool in calling library tools. One can easily include</span><br><span class="line">library headers he wants by declaring the corresponding macros.</span><br><span class="line">I hope this file is not only a header, but also a useful Linux library note.</span><br><span class="line">History:</span><br><span class="line">2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot;</span><br><span class="line">2012-08-20: Add shared memory library; add message queue.</span><br><span class="line">2012-08-21: Add socket library (local)</span><br><span class="line">2012-08-22: Add math library</span><br><span class="line">2012-08-23: Add socket library (internet)</span><br><span class="line">2012-08-24: Add daemon function</span><br><span class="line">2012-10-10: Change file name as &quot;AMCCommonLib.h&quot;</span><br><span class="line">2012-12-04: Add UDP support in AMC socket library</span><br><span class="line">2013-01-07: Add basic data type such as &quot;sint8_t&quot;</span><br><span class="line">2013-01-18: Add CFG_LIB_STR_NUM.</span><br><span class="line">2013-01-22: Add CFG_LIB_TIMER.</span><br><span class="line">2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h</span><br><span class="line">Copyright information:</span><br><span class="line">This file was intended to be under GPL protocol. However, I may use this library</span><br><span class="line">in my work as I am an employee. And my company may require me to keep it secret.</span><br><span class="line">Therefore, this file is neither open source nor under GPL control.</span><br><span class="line">********************************************************************************/</span><br></pre></td></tr></table></figure></li><li><p>方法、函数、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，<br> 好处是可以在引用的地方<code>alt+点击</code>查看注释，非常方便</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一些良好的注释：</span><br><span class="line"></span><br><span class="line">objective-c</span><br><span class="line">/**</span><br><span class="line"> *  Create a new preconnector to replace the old one with given mac address.</span><br><span class="line"> *  NOTICE: We DO NOT stop the old preconnector, so handle it by yourself.</span><br><span class="line"> *</span><br><span class="line"> *  @param type       Connect type the preconnector use.</span><br><span class="line"> *  @param macAddress Preconnector&apos;s mac address.</span><br><span class="line"> */</span><br><span class="line">- (void)refreshConnectorWithConnectType:(IPCConnectType)type  Mac:(NSString *)macAddress;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Stop current preconnecting when application is going to background.</span><br><span class="line"> */</span><br><span class="line">-(void)stopRunning;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Get the COPY of cloud device with a given mac address.</span><br><span class="line"> *</span><br><span class="line"> *  @param macAddress Mac address of the device.</span><br><span class="line"> *</span><br><span class="line"> *  @return Instance of IPCCloudDevice.</span><br><span class="line"> */</span><br><span class="line">-(IPCCloudDevice *)getCloudDeviceWithMac:(NSString *)macAddress;</span><br><span class="line"></span><br><span class="line">// A delegate for NSApplication to handle notifications about app</span><br><span class="line">// launch and shutdown. Owned by the main app controller.</span><br><span class="line">@interface MyAppDelegate : NSObject &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>协议、委托的注释要明确说明其被触发的条件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objective-c</span><br><span class="line">/** Delegate - Sent when failed to init connection, like p2p failed. */</span><br><span class="line">-(void)initConnectionDidFailed:(IPCConnectHandler *)handler;</span><br></pre></td></tr></table></figure></li><li><p>如果在注释中要引用参数名或者方法函数名，使用 <code>||</code> 将参数或者方法括起来以避免歧义：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objective-c</span><br><span class="line">// Sometimes we need |count| to be less than zero.</span><br><span class="line">// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift中iOS应用程序的MVVM模式</title>
      <link href="/2016/06/18/MVVM%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/06/18/MVVM%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="Swift中iOS应用程序的MVVM模式：一个实用的方法"><a href="#Swift中iOS应用程序的MVVM模式：一个实用的方法" class="headerlink" title="Swift中iOS应用程序的MVVM模式：一个实用的方法"></a><code>Swift</code>中<code>iOS</code>应用程序的<code>MVVM</code>模式：一个实用的方法</h3><figure class="image-box">                <img src="image/The-MVVM-Pattern-for-iOS-Apps-in-Swift-a-Pragmatic-Approach.png" alt="" title="" class="">                <p></p>            </figure><p><code>MVVM</code>最近在<code>iOS</code>开发社区中变得很流行。</p><p>但它并非没有争议，</p><p>我就是其中一个，我对<code>MVVM</code>的一些实现持保留意见，但我也认为它的一些想法是合理的。</p><p>在谈到缺点时，我不仅仅站在理论的角度，</p><p>我在真实的项目中也体验过它们。</p><p>我参与了一些跟随其中一些想法的项目，其中一个项目来自一家知名公司，结果该项目相对于计划延迟了几年发布。</p><p>几年时间，</p><p>你想想看。</p><p>虽然我不能说只有这一个原因，但所有这些原因中肯定包含对<code>MVVM</code>的实践。</p><p>在本文中，我们将看到：</p><ul><li><code>MVVM</code>和<code>MVC</code>之间的关系</li><li><code>MVVM</code>的详细信息</li><li><code>MVVM</code>模式中，网络请求代码应该放在哪里</li><li><code>MVVM</code>和实用的响应式编程框架，如<code>RxSwift</code></li><li>不同方法的优缺点</li><li>一个避免了许多问题的实用的方法，并包含具体的例子</li></ul><h3 id="在MVC模式中，View不应该知道相关App中Model的任何信息"><a href="#在MVC模式中，View不应该知道相关App中Model的任何信息" class="headerlink" title="在MVC模式中，View不应该知道相关App中Model的任何信息"></a>在<code>MVC</code>模式中，<code>View</code>不应该知道相关App中<code>Model</code>的任何信息</h3><p>让我们从我们试图解决的实际问题开始。</p><p>我在<code>iOS</code>应用中看到的最常见的<code>MVC</code>模式违规之一发生在<code>View</code>与应用的<code>Model</code>类型相关联时。</p><p>像任何重大错误一样，我过去也犯过这个错误，所以我很清楚它的样子。</p><p><a href="http://matteomanferdini.com/the-concepts-at-the-foundation-of-any-ios-app/" target="_blank" rel="noopener">我在文章中经常指出<code>MVC</code>模式的各个层</a>，我可以将<code>iOS</code>应用中的大部分问题都联系到违反这些原则的行为。</p><p>作为回顾，<code>iOS MVC</code>模式将我们的类型划分为4个（而不仅仅是3个）层：</p><ul><li><code>Model</code>类型代表数据以及业务逻辑</li><li><code>Model Controller</code>是与设备的接口，并以特定于应用的方式处理<code>Model</code>类型。例如保存App的状态，<br>  保存数据到磁盘或访问网络</li><li><code>View</code>在屏幕上展示信息并允许用户交互</li><li><code>View Controller</code>是<code>View</code>和<code>MVC</code>模式中较低层之间的桥梁。它将用于显示的数据传送给<code>View</code>，<br>  并解释用户的交互，指定应用程序屏幕的流程</li></ul><figure class="image-box">                <img src="image/The-basic-structure-of-the-MVC-pattern-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p><a href="https://matteomanferdini.com/understanding-the-core-architectural-principles-of-ios-development-with-a-practical-example/" target="_blank" rel="noopener">我已经写了很多关于这个的文章</a></p><p>正如我们在上面的观点中看到的，<code>View</code>需要从<code>View Controller</code>接收数据用于显示，它不直接访问<code>Model</code>。</p><h3 id="Model类型和View之间的桥接有其自身的问题"><a href="#Model类型和View之间的桥接有其自身的问题" class="headerlink" title="Model类型和View之间的桥接有其自身的问题"></a><code>Model</code>类型和<code>View</code>之间的桥接有其自身的问题</h3><p>将数据传递给<code>View Controller</code>中的<code>View</code>的问题来自以下事实，因为那样做会很容易：</p><ul><li>将<code>Model</code>类型直接传递给<code>View</code>以在屏幕上渲染</li><li>让<code>View Controller</code>对<code>View</code>的内部实现了解太多</li></ul><p>开发者经常做任何一个（或都做），因为它们是快速的解决方案。</p><p>但是两者都会引发问题，因为它们导致模块之间的耦合。第一个导致<code>Model</code>类型和<code>View</code>之间的耦合，<br>第二个在<code>View Controller</code>和<code>View</code>之间。</p><p>耦合使我们的模块更难以重用并且更容易破坏。</p><p>让我们更详细地看看这两个问题，</p><p>开发者经常将<code>Model</code>类型直接传递给<code>View</code>，以便<code>View</code>可以自己读取这些数据的格式。<br>但是如果你看看<code>MVC</code>中的角色，格式化数据并不是<code>View</code>的责任</p><p>这会在<code>View</code>和<code>Model</code>类型之间创建耦合，这意味着：</p><ul><li><code>View</code>很难在不同的屏幕之间以及不同的应用之间复用，如果要使用相同的<code>View</code>来展示另一个数据类型，事情就变得复杂了。<br>  这个视图需要知道两种不同的类型，并且能够区分它们。如果你想要在其他项目中重用这个<code>View</code>，则需要携带所有这些依赖项。</li></ul><ul><li><code>View</code>的实现捆绑到<code>Model</code>的实现，这意味着<code>Model</code>的任何改变都可能会破坏<code>View</code>的代码，然后需要重写代码。<br>  这可能不是那么简单，特别是如果<code>View</code>依赖于多个<code>Model</code>类型。</li></ul><p><code>MVC</code>模式使<code>View</code>独立于<code>Model</code>类型来解决这个问题，在<code>iOS</code>版<code>MVC</code>方案中，<code>View</code>和<code>Model</code>之间没有箭头。</p><p>这意味着<strong><code>View</code>仅获取简单格式的数据</strong></p><p>事实上，如果你查看<code>UIKit</code>框架的所有<code>UIView</code>，它们就会以这种方式工作。<code>Label</code>只需要一个简单的<code>String</code>来展示，  <code>Switch</code>、<code>Slider</code>、<code>ProgressView</code>只需要简单的类型，如<code>Bool</code>、<code>Int</code>、<code>Float</code>。</p><p>像<code>UITableView</code>这样复杂的视图会附加到<code>DataSource</code>。<br>为此，它让<code>Cell</code>来显示，请注意，<code>UITableView</code>不会要求数据，它只要求已经填充的<code>Cell</code>。</p><p>通过这种方式，<code>UITableView</code>可以保持通用，你可以将之用于应用中的任何<code>Model</code>类型。</p><h3 id="View不应该暴露其内部实现"><a href="#View不应该暴露其内部实现" class="headerlink" title="View不应该暴露其内部实现"></a><code>View</code>不应该暴露其内部实现</h3><p>当<code>View Controller</code>或其它对象对<code>View</code>的内部实现了解太多时，会发生对<code>MVC</code>模式的另一种违反。</p><p>你可以在<code>UITableView</code>的<code>DataSource</code>中经常看到这一点。</p><p><code>DataSource</code>需要在将<code>Cell</code>返回给<code>UITableView</code>之前用数据填充<code>Cell</code>。</p><p>一个常见的错误是让<code>DataSource</code>访问<code>Cell</code>的子视图来填充数据，</p><p>因此，<code>DataSource</code>经常访问<code>Cell</code>的<code>UILabel</code>、<code>UIImageView</code>和其它子视图以给它们赋值。<br>这可以通过<code>UIOutlet</code>发生，或者更糟糕的是，使用<code>UIview.viewWithTag()</code>方法，</p><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/TableView_iPhone/TableViewCells/TableViewCells.html#//apple_ref/doc/uid/TP40007451-CH7-SW18" target="_blank" rel="noopener">你甚至可以在苹果的官方文档中找到它们</a></p><p>这里的问题是这又引入了耦合，当我们更改<code>Cell</code>的实现时，我们会破坏访问它的所有<code>DataSource</code>。</p><p><code>UILabel</code>和其它子视图是<code>View</code>内部实现的一部分，任何对象都不应该依赖于另一个对象的内部实现。</p><p>事实上，<code>UIOutlet</code>甚至不应该暴露出来，我明确地将我代码中的<code>UIOutlet</code>都标记为<code>private</code>，<br><strong><code>UIOutlet</code>的所有者是唯一访可以问它的人</strong>。</p><p>这里的解决方案和上面的一样，<code>Cell</code>是一个<code>View</code>，和其它的<code>View</code>一样，因此，<a href="https://matteomanferdini.com/the-correct-way-to-display-lists-in-ios-and-what-many-developers-do-wrong/" target="_blank" rel="noopener">它只接受一种简单的数据格式</a>。<br>然后，自己有填充内部<code>UIOutlet</code>的责任。</p><h3 id="在View-Controller中做数据转换不是最优的"><a href="#在View-Controller中做数据转换不是最优的" class="headerlink" title="在View Controller中做数据转换不是最优的"></a>在<code>View Controller</code>中做数据转换不是最优的</h3><p>所以关于<code>View</code>的指导方针是：</p><ul><li>不要传递任何<code>Model</code>类型给它们</li><li>不要访问它们的内部实现</li></ul><p>正如我们所看到的，两者的解决方式是相同的：<strong><code>View</code>应该接受简单类型的数据</strong>。</p><p>因此，我们需要将<code>Model</code>类型的数据转换为简单类型，</p><p>这个转换过程通常在哪里完成？</p><p>确切地说：在<code>View Controller</code>内部。</p><p>诱惑有时候是把它放到<code>Model</code>类型中，但是<code>Model</code>类型不应该知道如何向用户呈现数据。</p><p>同样的数据在应用程序不同的部分可以有不同的呈现方式，这样就赋予<code>Model</code>类型太多职责而违反了<code>MVC</code>模式。</p><p><code>Model Controller</code>也不是正确的位置，它们只处理数据但并不关心他们怎么呈现。</p><p>现在就剩下<code>View Controller</code>了，但这同样也有问题。</p><p>要清楚，这并不是错误的。如果你遵循上面的<code>View</code>准则并将<code>MVC</code>定义的职责分开，那么你已经比很多复制-粘贴开发人员更胜一筹。</p><p>但是在<code>View Controller</code>中放置数据转换并不是最佳选择：</p><ul><li><p>首先，我们知道在<code>View Controller</code>中的代码往往会增长很多，<a href="https://matteomanferdini.com/how-to-structure-the-code-of-ios-apps/" target="_blank" rel="noopener">因为它在<code>iOS</code>中起着核心的作用</a>，<br>  因此，在可能的情况下，最好避免对这个问题作出贡献</p></li><li><p>这同样也影响代码重用，如果我们想在另一个界面使用相同的<code>View</code>，我们需要找到一种在<code>View Controller</code><br>  之间共享转换代码的方式</p></li></ul><p>也有一些这方面的解决方案。</p><p>例如，我们可以使用<code>Swift Extension</code>对相关的转换代码进行分组，这是一种有效的方法。</p><p>另一种方法是遵循<code>MVVM</code>模式。</p><h3 id="MVVM模式是MVC模式的扩展"><a href="#MVVM模式是MVC模式的扩展" class="headerlink" title="MVVM模式是MVC模式的扩展"></a><code>MVVM</code>模式是<code>MVC</code>模式的扩展</h3><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM模式</a>由微软公司开发。</p><p>是的，我知道，这很震惊。</p><p><code>MVVM</code>模式源于<code>MVC</code>模式，它旨在解决在<code>View Controller</code>内部发生模型对象转换的问题。</p><p><code>MVVM</code>的想法很简单。</p><p><strong>我们在<code>MVC</code>模式中的<code>View</code>和<code>View Controller</code>之间引入一个新层</strong>，负责处理数据转换。</p><figure class="image-box">                <img src="image/The-basic-structure-of-the-MVVM-pattern-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p>（是的，我知道这个图解不准确，请继续阅读。）</p><p>听起来相当简单，不是吗？</p><p>不幸的是，在<code>iOS</code>中，<code>MVVM</code>模式有其自身的问题。</p><p>像上面这样的图的缺点是它没有显示这些层之间的相互作用的所有细微差别，</p><p>这留下太多需要自我理解的东西。</p><p>如果你阅读关于<code>MVVM</code>的<code>iOS</code>开发文章，你会发现围绕它的不同想法，甚至<code>MVVM</code>呼声最高的支持者也不同意其中的一些观点。</p><p><a href="http://khanlou.com/2015/12/mvvm-is-not-very-good/" target="_blank" rel="noopener">本文对<code>MVVM</code>的分歧有很好的总结</a>，</p><p>这是让我长时间对<code>MVVM</code>持怀疑态度的原因之一，直到我找到了更实用的方法。</p><p>让我们看看这些问题。</p><h3 id="View-Model应该是值类型，而不是引用类型"><a href="#View-Model应该是值类型，而不是引用类型" class="headerlink" title="View Model应该是值类型，而不是引用类型"></a><code>View Model</code>应该是值类型，而不是引用类型</h3><p>我在<code>MVVM</code>中发现的第一个重大问题是将<code>View Model</code>作为引用类型。</p><p>这可能看起来像一个小细节，但是它有很大的影响。</p><p>在这个话题上，我和Andy Matuschack站在同一阵营。他非常好的讨论了我真正推荐的<a href="https://academy.realm.io/posts/andy-matuschak-controlling-complexity/" target="_blank" rel="noopener">引用类型和值类型之间的区别</a>。</p><p>这个观点是：</p><ul><li>值类型是惰性的，只能有一个所有者，这使得更容易推断它们的代码</li><li>引用类型可以拥有许多所有者，它们接受来至其它对象的方法调用，全局通知，回调，<code>KVO</code>通知等，这使得很难推断其代码</li></ul><p>这显示了<code>View Model</code>作为参考类型如何产生巨大差异。<code>View Model</code>成为有状态对象，可以通过代码的不同部分进行更新，<br>这通常会导致意外行为和奇怪的Workaround。</p><p>突然之间，你在<code>MVC</code>中有第三层，它本身就是行为。</p><p>您可以在<a href="https://www.objc.io/issues/13-architecture/mvvm/" target="_blank" rel="noopener"><code>iOS</code>的<code>MVVM</code>的大多数图解</a>中清楚地看到这一点，这通常采用以下形式：</p><figure class="image-box">                <img src="image/A-wrong-diagram-for-MVVM-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p>我只是为了向您展示相关信息，但我建议不要采用这种方法。</p><p>在这里你可以清楚地看到：</p><ul><li><code>View Model</code>是一个行为层。它<strong>拥有</strong><code>Model</code>并通过某种形式的通知或回调进行更新</li><li>甚至<code>Model</code>类型也是引用类型，这是它们能够向<code>View Model</code>发送信号的唯一方式</li><li>它似乎完全忽略了<code>MVC</code>的<code>Model Controller</code>层，实际上，<code>View Model</code>似乎取代了该方案中的<code>Model Controller</code></li></ul><p>行为<code>View Model</code>有很大的缺点。首先，你可以看到，在没有更多职责的情况下，它们至少有两个职责，<br>它们在将数据传递给<code>View</code>之前检索数据并对其进行格式化。</p><p>实际上，Andy Matuschak本人在他关于<a href="https://academy.realm.io/posts/andy-matuschak-refactor-mega-controller/" target="_blank" rel="noopener">重构<code>Mega Controller</code>的一次谈话中</a>发表了这番话。<br>在45:08时，他解释了<code>MVVM</code>中数据转换部分是正确的，但其余的都是错误的。</p><p>观看整个演讲，最大程度地影响了我写<code>iOS</code>应用程序方式。</p><p>因此，<code>View Model</code>作为参考类型天生存在问题。</p><p>但这只是冰山一角。</p><h3 id="网络代码不应该进入View-Model"><a href="#网络代码不应该进入View-Model" class="headerlink" title="网络代码不应该进入View Model"></a>网络代码不应该进入<code>View Model</code></h3><p><code>View Model</code>的另一个问题是，这个版本的<code>MVVM</code>的一些支持者认为，<a href="http://artsy.github.io/blog/2015/09/24/mvvm-in-swift/" target="_blank" rel="noopener">网络代码应该放在<code>View Model</code>中</a>。</p><p>在这里，我们看到将<code>View Model</code>作为引用类型的一个重要影响。如果它们是值类型，则这是不可能的。</p><p>在您的<code>MVVM</code>版本中，网络代码放在<code>View Model</code>中是可以理解的：</p><ul><li>没有考虑<code>Model Controller</code>的存在</li><li>明确声明<code>View Model</code>的行为以及通过回调或某种形式的通知来更新<code>View Controller</code></li></ul><p>这使得<code>View Controller</code>和<code>View Model</code>成为网络代码的唯一候选者。</p><p>由于每个人都知道<code>View Controller</code>已经太大了，因此网络代码自然而然的放在了<code>View Model</code>中。</p><p>这会在难以理解的对象之间创建一个非常复杂的回调网络，并导致许多错误。</p><p>我们甚至没有考虑单元测试，这会造成更多问题。</p><p>我已经证明<a href="http://matteomanferdini.com/network-requests-rest-apis-ios-swift/" target="_blank" rel="noopener">网络代码应该转移到<code>Model Controller</code>内部</a>，并且<code>Model type</code>应该是惰性值类型。</p><p>我们是否解决了这些问题？</p><p>还没有。</p><p>此版本的<code>MVVM</code>鼓励另一种模式，这对我来说像是<code>iOS</code>中的异步代码的灾难之源：<code>函数响应式编程</code>。</p><h3 id="函数响应式编程框架隐藏了幕后的大量复杂性"><a href="#函数响应式编程框架隐藏了幕后的大量复杂性" class="headerlink" title="函数响应式编程框架隐藏了幕后的大量复杂性"></a><code>函数响应式编程</code>框架隐藏了幕后的大量复杂性</h3><p>与此版本的<code>MVVM</code>经常相关的一件事是<code>函数响应式编程</code>（<code>FRP</code>）。</p><p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>是异步数据流的编程范例，它使用函数式编程的构建块，如map，reduce和filter。</p><p>在<code>iOS</code>中，<code>FRP</code>通常有不同的风格：</p><ul><li><code>RxSwift</code></li><li><code>ReactiveSwift</code>  和  <code>ReactiveCocoa</code></li></ul><p>使用<code>FRP</code>框架时，您的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let searchResults = searchBar.rx.text.orEmpty</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in</span><br><span class="line">        if query.isEmpty &#123;</span><br><span class="line">            return .just([])</span><br><span class="line">        &#125;</span><br><span class="line">        return searchGitHub(query)</span><br><span class="line">            .catchErrorJustReturn([])</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line"> </span><br><span class="line">searchResults</span><br><span class="line">    .bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">        (index, repository: Repository, cell) in</span><br><span class="line">        cell.textLabel?.text = repository.name</span><br><span class="line">        cell.detailTextLabel?.text = repository.url</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>我最初写了这段代码的详细分析，然后意识到这是浪费你我的时间。</p><p>我只想写几个注意事项，</p><p>这段代码隐藏了很多幕后的复杂性，即使在不需要异步代码的地方，也有很多异步操作和回调在后台进行。</p><p>实际上，您可以在<code>RxSwift</code>的文档页面中清楚地看到它，<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Why.md" target="_blank" rel="noopener">它涉及<code>binding</code>, <code>retrie</code>, <code>delegate</code>, <code>KVO</code>, <code>Notification</code></a>等。</p><p><code>FRP</code>背后的想法是你编写“声明性”代码并放弃对异步操作的控制。这正是我对<code>FRP</code>不喜欢的，它的代码不够明确。</p><p><code>FRP</code>粉丝通常回答：“但看看我写的代码有多少，它就像魔法一样！“</p><p>对我来说，这正是问题所在。</p><p>在软件开发中，<strong>如果某些东西看起来太聪明或看起来像魔术，那可能是个坏主意</strong></p><p>这种方法使编写代码变得非常容易，但：</p><blockquote><p>Programs must be written for people to read, and only incidentally for machines to execute.<br>程序必须写得能供人阅读，机器执行只是附带  </p><ul><li>Harold Abelson</li></ul></blockquote><p>这是一个定义问题，<code>FRP</code>的支持者会告诉你，这段代码正是如此：完全可读。</p><p>对我而言，事实并非如此。它达到如此高的抽象水平，很难知道它究竟做了什么。</p><p>此外，尝试在几个月内调试问题，此时您将无法了解所有这些异步代码的工作原理。正如Brian Kernighan曾经说过：</p><blockquote><p>每个人都知道调试的难度是最初编写程序的两倍。因为，如果您在编写时足够聪明，那么您现在怎么会调试它？</p></blockquote><p>这一点与上面讨论的相同。这会创建一个复杂的对象网络，它们以自己的方式运行，这使得很难推断出这段代码。</p><p>当然，你可以写得很快。但代码是写一次而读很多次。你将为节省时间付出代价。</p><p>最后，团队中的每个人都需要学习一个全新的范例。这段代码肯定很短，但<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="noopener"><code>RxSwift</code>的文档肯定不短</a>。</p><p>最后一个问题是<code>FRP</code>是一个范例，它的实现是不同的。</p><p><a href="https://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons" target="_blank" rel="noopener">在Stack Overflow上查看关于<code>RxSwift</code>和<code>ReactiveCocoa</code></a>的关于这个问题的答案。它在一开始就说：“比较两个世界是非常困难的”。<br>后来，结论是：“<code>RAC</code>和<code>RxSwift</code>是两个完全不同的野兽”。</p><p>所以这些范例不可互换。即使您了解一个<code>FRP</code>框架，当您使用另一个框架时，您可能还需要重新学习所有内容。</p><p>最后，选择权归你所有。在我看来，它产生的问题多于解决的问题。</p><p>如果你喜欢这种魔法编程，那就去吧。但是你可能就不喜欢我在材料中写的大部分内容。</p><p>相反，如果您想要遵循不同的<code>MVC</code>和<code>MVVM</code>方法，请继续阅读。</p><h3 id="View-Model作为惰性值类型"><a href="#View-Model作为惰性值类型" class="headerlink" title="View Model作为惰性值类型"></a><code>View Model</code>作为惰性值类型</h3><p>如果我们修改我们的<code>View Model</code>为值类型，我上面说明的所有内容都不再可能。</p><p>在<code>View Model</code>中不再有状态，网络和<code>FRP</code>，</p><p>这很好。</p><p>这种<code>MVVM</code>模式的<code>View Model</code>层变得惰性。因此，它不能是<code>View Controller</code>和<code>Model</code>之间的连接层。</p><p><code>View Model</code>变成了一个帮助层，它位于<code>View Controller</code>和<code>View</code>旁边，而不是它们之间。</p><p><code>View Model</code>的唯一责任就是以正确的格式将数据传递给<code>View</code>。我们所知道的<code>MVC</code>的各层之间的连接受到尊重：</p><figure class="image-box">                <img src="image/A-pragmatic-approach-to-MVVM-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p>您可以看到<code>View Model</code>中没有箭头。这是因为，正如名称所述，它们是模型对象。模型实体是惰性值类型。</p><p>但与我们的应用程序的模型类型（代表数据和业务逻辑）不同，<code>View Model</code>代表可视信息。</p><p>这允许我们：</p><ul><li>从<code>View Controller</code>中接管数据格式化的责任</li><li>定义简单视图类型以将数据传递给<code>View</code></li><li>使转换代码和自定义视图可以在我们的应用程序甚至跨不同项目中重复使用</li><li>扩展视图模型，以便相同的自定义视图可以显示不同类型的数据</li></ul><p>像往常一样，让我们​​看看所有这些理论的实际应用。</p><p>我们将构建一个显示航班信息的简单应用程序。</p><p>这将允许我显示模型类型，视图模型和转换代码之间的明确分离。</p><figure class="image-box">                <img src="image/Design-of-the-MVVM-example-app.png" alt="" title="" class="">                <p></p>            </figure><h3 id="MVVM的基本块是自定义视图"><a href="#MVVM的基本块是自定义视图" class="headerlink" title="MVVM的基本块是自定义视图"></a><code>MVVM</code>的基本块是自定义视图</h3><p>让我们从简单的东西开始吧。</p><p>首先，我们在<code>interface builder</code>中为<code>View Controller</code>创建界面。</p><figure class="image-box">                <img src="image/UI-for-the-MVVM-example-app-in-Interface-Builder-1024x650.png" alt="" title="" class="">                <p></p>            </figure><p>在这里，我使用简单<code>UIView</code>和<code>UILabel</code>的组合创建了遵循上述设计的卡片。</p><p>我使用<code>UIStackView</code>和<code>Auto Layout constraint</code>的组合放置了这些视图。我还为卡片周围的阴影设置了一些<br>用户定义的运行时属性。您可以在图像右侧看到这些值。</p><p>但这不是重要的事情。</p><p>由于这不是关于<code>Auto Layout</code>和<code>UI</code>的文章，我不会详细介绍。你可以<a href="https://github.com/matteom/FlightInfo" target="_blank" rel="noopener">在Github上找到他们的Xcode项目</a>，<br>并<a href="https://matteomanferdini.com/understanding-the-core-architectural-principles-of-ios-development-with-a-practical-example/" target="_blank" rel="noopener">在这篇文章中较长的讨论</a>，或在<a href="http://matteomanferdini.com/ultimate-course-making-professional-ios-apps/" target="_blank" rel="noopener">我的专业制作iOS应用免费课程</a>。</p><p>重要的是，根据我们的<code>MVVM</code>版本，这个<code>View</code>需要有一个自定义类，它隐藏了它的内部实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FlightCardView: UIView &#123;</span><br><span class="line">@IBOutlet private weak var airportSymbolsLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureAirportLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var airlineLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var flightNumberLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var durationLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalAirportLabel: UILabel!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，<code>FlightCardView</code>引用它自己的子视图，在这个例子中都是<code>UILabel</code>，通过<code>UIOutlet</code>连接。</p><p>通常看到<code>UIOutlet</code>仅从<code>View Controller</code>到其<code>View</code>中的所有界面元素。但是<code>View</code>也可以拥有到其子视图的<code>UIOutlet</code>。</p><p>这是<code>MVVM</code>的基本组成部分。</p><p>当<code>View Controller</code>具有到所有在其<code>View</code>中的接口元素的<code>UIOutlet</code>时，这意味着它对该<code>View</code>的内部实现了解太多。<br>所以它违反了我们上面列出的指导方针。</p><p>相反，使用自定义视图，<code>View Controller</code>不需要很多<code>UIOutlet</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class FlightInfoViewController: UIViewController &#123;</span><br><span class="line">@IBOutlet private weak var cardView: FlightCardView!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，我们的<code>View Controller</code>实际上只有一个<code>UIOutlet</code>。</p><h3 id="View不需要关心Model类型的结构"><a href="#View不需要关心Model类型的结构" class="headerlink" title="View不需要关心Model类型的结构"></a><code>View</code>不需要关心<code>Model</code>类型的结构</h3><p>我们现在将移动到<code>MVC</code>的另一端并为我们的应用程序创建<code>Model</code>类型。</p><p>如果您查看上面的自定义视图的代码，您将看到它具有扁平结构。那个类所拥有的所有东西仅仅是到<code>UILabel</code>的<code>UIOutlet</code>。</p><p>这并不意味着我们的<code>Model</code>类型需要具有相同的扁平结构。也不意味着如果我们最终得到的<code>Model</code>类型不能反映其扁平结构时<br>需要更新我们的视图。</p><p>这个概念是<code>MVC</code>和<code>MVVM</code>的核心。</p><p><strong><code>View</code>和<code>Model</code>类型完全脱离开</strong>。前者仅关注如何向用户呈现信息。后者，只关心如何在内部表示数据。</p><p>他们不需要彼此了解任何事情，也不需要以任何方式相互映射。他们甚至可能以完全不同的方式表示信息。</p><p>在<code>MVC</code>中，<code>View Controller</code>负责桥接这一间隙。在<code>MVVM</code>中，它将是<code>View Model</code>的责任。</p><p>因此，让我们开始考虑我们的航班信息所需的数据结构。</p><p>一个航班连接着机场，世界上有许多机场。所以我们需要一个机场结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Airport &#123;</span><br><span class="line">let symbol: String</span><br><span class="line">let name: String</span><br><span class="line">let city: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我只创建了我们Demo所需要的属性。当然，你可以添加其他的，并使其中一些甚至有自己的自定义类型。</p><p>航班不仅仅是机场。特定航班在特定时间离开或到达机场。我们可以称这些为端点，一个航班有两个端点：出发和到达。</p><p>所以我们声明一个结构来表示端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Endpoint &#123;</span><br><span class="line">let date: Date</span><br><span class="line">let airport: Airport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，航班由航空公司运营，并有一个识别它的号码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Flight &#123;</span><br><span class="line">let airline: String</span><br><span class="line">let number: String</span><br><span class="line">let departure: Endpoint</span><br><span class="line">let arrival: Endpoint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们看一下我们小巧的应用程序的设计，我们需要最后一个属性。</p><p>航班有持续时间。抛开我们想要在屏幕上显示它的事实来说，持续时间是航班的属性，因此它属于这个模型。<br>例如，将来我们可能会使用持续时间对航班进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Flight &#123;</span><br><span class="line">let airline: String</span><br><span class="line">let number: String</span><br><span class="line">let departure: Endpoint</span><br><span class="line">let arrival: Endpoint</span><br><span class="line"></span><br><span class="line">var duration: TimeInterval &#123;</span><br><span class="line">return arrival.date.timeIntervalSince(departure.date)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两件事很重要：</p><ul><li>这些<code>Model</code>类型的结构与<code>View</code>的结构不同。虽然<code>View</code>是扁平的，但我们的<code>Model</code>类型按层次结构组织（请参见下图）</li><li>数据表示也不同。虽然我们的<code>View</code>以格式化字符串的形式显示所有内容，但在我们的<code>Model</code>类型中，我们有<code>Date</code>和      <code>TimeInterval</code>类型。数据表示和数据可视化是分开的。无论<code>View</code>可能需要什么，该<code>Model</code>都使用最佳类型进行表示</li></ul><figure class="image-box">                <img src="image/The-data-model-layer-of-the-app.png" alt="" title="" class="">                <p></p>            </figure><h3 id="View-Model以最终格式向View提供数据"><a href="#View-Model以最终格式向View提供数据" class="headerlink" title="View Model以最终格式向View提供数据"></a><code>View Model</code>以最终格式向<code>View</code>提供数据</h3><p>现在让我们使用<code>View Model</code>桥接<code>Model</code>类型和<code>View</code>之间的间隙。</p><p>如上所述，<code>View Model</code>是用于将数据传递给<code>View</code>的简单类型。因此，他们需要以<code>View</code>所需的格式向<code>View</code>提供数据。</p><p>我们的<code>View</code>需要其<code>UILabel</code>的字符串，没有别的。</p><p>这正是我们的<code>View Model</code>需要提供的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension FlightCardView &#123;</span><br><span class="line">struct ViewModel &#123;</span><br><span class="line">let airportSymbols: String</span><br><span class="line">let departureDay: String</span><br><span class="line">let departureAirport: String</span><br><span class="line">let airline: String</span><br><span class="line">let flightNumber: String</span><br><span class="line">let duration: String</span><br><span class="line">let arrivalDay: String</span><br><span class="line">let arrivalAirport: String</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，我们的<code>View Model</code>是一个结构体，因此它是一个惰性值类型：</p><ul><li>它没有行为表现</li><li>它不会自己访问<code>Model</code></li><li>它没有收到回调和通知</li><li>它不会进行网络请求</li><li>它不会更新<code>View</code></li></ul><p>所有这些职责保留在<code>Model Controller</code>和<code>View Controller</code>中。</p><p>此外，我们的<code>View Model</code>的所有属性都是<code>String</code>类型，这个很重要。</p><p><code>View</code>仅涉及数据可视化，而不涉及数据转换。组合字符串或格式化数据不是它的职责。</p><p>我们的<code>FlightCardView</code>需要已经采用适合其<code>UILabel</code>的最终格式的数据。</p><p>此<code>ViewModel</code>是<code>FlightCardView</code>类的一部分。因此，它是<code>FlightCardView</code>的子类型。<br>我通常将这些类型放在单独的扩展中以便更好地组织代码。您也可以直接在<code>FlightCardView</code>中声明它们。<br>这只是一种风格问题。</p><p>无论哪种方式，此<code>View Model</code>的<code>scope name</code>是<code>FlightCardView.ViewModel</code>。<br>这清楚地表明这个结构的唯一目的是将数据传递给 <code>FlightCardView</code>。</p><h3 id="将数据类型中的数据转换为View-Model的格式"><a href="#将数据类型中的数据转换为View-Model的格式" class="headerlink" title="将数据类型中的数据转换为View Model的格式"></a>将数据类型中的数据转换为<code>View Model</code>的格式</h3><p>现在我们需要编写将<code>Model</code>类型转换为<code>ViewModel</code>值的代码。</p><p>此代码属于<code>ViewModel</code>本身，这正是它所起到的作用。</p><p>然而有时我们想让一些代码可以在不同的<code>ViewModel</code>中重用。</p><p>例如，我们的应用程序中可能有其他<code>View</code>显示日期。这意味着我们需要更多的<code>ViewModel</code>将<code>Date</code>转换为<br>具有特定格式的<code>String</code>。通常在应用程序的所有屏幕上使用相同的数据格式。</p><p>所以我们可以将这些代码放在<code>Date Extension</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension Date &#123;</span><br><span class="line">var day: String &#123;</span><br><span class="line">let formatter = DateFormatter()</span><br><span class="line">formatter.dateStyle = .full</span><br><span class="line">formatter.timeStyle = .none</span><br><span class="line">return formatter.string(from: self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var time: String &#123;</span><br><span class="line">let formatter = DateFormatter()</span><br><span class="line">formatter.dateFormat = &quot;HH:mm&quot;</span><br><span class="line">return formatter.string(from: self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们从<code></code>Date中提取<code>day</code>和<code>time</code>，因为在我们的设计中我们需要分别地使用它们。</p><p>同样，<code>duration</code>也有自己的格式。我们需要将用秒来表示的<code>TimeInterval</code>转换成像这样的一个字符串“ 3 小时，10 分钟 ”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension TimeInterval &#123;</span><br><span class="line">var formatted: String &#123;</span><br><span class="line">let secondsInAnHour = 60 * 60</span><br><span class="line">let hours = Int(self) / secondsInAnHour</span><br><span class="line">let minutes = (Int(self) % secondsInAnHour) / 60</span><br><span class="line">return &quot;\(hours) hours, \(minutes) minutes&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的设计中，我们还看到时间和机场信息组合在同一条线上。所以我们需要代码将时间，城市和机场名称组合成一个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Endpoint &#123;</span><br><span class="line">var timeAndAirport: String &#123;</span><br><span class="line">return date.time</span><br><span class="line">+ &quot; &quot;</span><br><span class="line">+ airport.city</span><br><span class="line">+ &quot;, &quot;</span><br><span class="line">+ airport.name</span><br><span class="line">+ &quot; Airport&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还是将此代码放入<code>Endpoint Extension</code>中，但实际上将它放置在哪里取决于你怎样使用它。</p><p>在这里，我假设我们将在我们的应用程序中的其他地方需要它。如果仅在一个<code>View Model</code>中需要此代码，<br>则最好将其放在这个特定的<code>View Model</code>中。</p><p>请记住，这些<code>Extension</code>是我们的数据格式化代码的一部分。因此，即使我们扩展了<code>Endpoint</code>结构，<br><strong>此代码也不是<code>Model</code>层的一部分</strong>。</p><p>此代码属于<code>View Model</code>层。因此，只有<code>View Model</code>才能使用它。在<code>Model</code>类型中使用这些扩展是一个错误。</p><p>如果您想更正式地强制执行此限制，可以将它们声明为<code>fileprivate</code>，这样它们就不会在应用的其他部分中显示出来。<br>但如果您在同一文件中放置了大量<code>View Model</code>，这也并不总是可行的。</p><p>最终我们可以编写将<code>Flight</code>转换为<code>ViewModel</code>的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">extension FlightCardView.ViewModel &#123;</span><br><span class="line">init(flight: Flight) &#123;</span><br><span class="line">let departure = flight.departure</span><br><span class="line">let arrival = flight.arrival</span><br><span class="line">airportSymbols = departure.airport.symbol + &quot; ➔ &quot; + arrival.airport.symbol</span><br><span class="line">departureDay = departure.date.day</span><br><span class="line">departureAirport = departure.timeAndAirport</span><br><span class="line">airline = flight.airline</span><br><span class="line">flightNumber = flight.number</span><br><span class="line">duration = flight.duration.formatted</span><br><span class="line">arrivalDay = arrival.date.day</span><br><span class="line">arrivalAirport = arrival.timeAndAirport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init() &#123;</span><br><span class="line">airportSymbols = &quot;&quot;</span><br><span class="line">departureDay = &quot;&quot;</span><br><span class="line">departureAirport = &quot;&quot;</span><br><span class="line">airline = &quot;&quot;</span><br><span class="line">flightNumber = &quot;&quot;</span><br><span class="line">duration = &quot;&quot;</span><br><span class="line">arrivalDay = &quot;&quot;</span><br><span class="line">arrivalAirport = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码接受一个<code>Flight</code>并将其数据转换为<code>FlightCardView</code>所需的各种字符串。</p><p>我还添加了一个初始化器来创建一个空<code>ViewModel</code>。这对于重置<code>FlightCardView</code>中<code>UILabel</code>的值很有用。<br>它还有助于从我们的代码中删除<code>optional</code>。</p><p>我将这些初始化器放在<code>Extension</code>中，因此我们不会丢失<code>ViewModel</code>结构的默认成员初始化器。这可能对单元测试很有用。</p><p>我们现在需要的是将<code>ViewModel</code>传递给<code>FlightCardView</code>的一种方法。 </p><p>我们可以通过一个观察属性<code>viewModel</code>来执行此操作，在每次设置新的<code>viewModel</code>时自动更新<code>UILabel</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FlightCardView: UIView &#123;</span><br><span class="line">@IBOutlet private weak var airportSymbolsLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureAirportLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var airlineLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var flightNumberLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var durationLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalAirportLabel: UILabel!</span><br><span class="line"></span><br><span class="line">var viewModel: ViewModel = ViewModel() &#123;</span><br><span class="line">didSet &#123;</span><br><span class="line">airportSymbolsLabel.text = viewModel.airportSymbols</span><br><span class="line">departureDayLabel.text = viewModel.departureDay</span><br><span class="line">departureAirportLabel.text = viewModel.departureAirport</span><br><span class="line">airlineLabel.text = viewModel.airline</span><br><span class="line">flightNumberLabel.text = viewModel.flightNumber</span><br><span class="line">durationLabel.text = viewModel.duration</span><br><span class="line">arrivalDayLabel.text = viewModel.arrivalDay</span><br><span class="line">arrivalAirportLabel.text = viewModel.arrivalAirport</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将来，我们还可以使用此<code>View</code>显示除<code>Flight</code>结构之外的数据。我们需要做的只是为<code>ViewModel</code>添加一个新的初始化器。</p><p>没有其他代码会改变，<code>FlightCardView</code>不会，<code>Flight</code>的结构也不会，甚至<code>ViewModel</code>结构都不会改变。</p><h3 id="View-Controller负责从Model到View的数据流"><a href="#View-Controller负责从Model到View的数据流" class="headerlink" title="View Controller负责从Model到View的数据流"></a><code>View Controller</code>负责从<code>Model</code>到<code>View</code>的数据流</h3><p>我们现在需要组合我们的应用程序，以在屏幕上显示一些信息。</p><p>正如<code>MVC</code>所规定的那样，<code>View Controller</code>传递数据流</p><p>首先，我们需要一些实际数据来显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private extension FlightInfoViewController &#123;</span><br><span class="line">func createFlight() -&gt; Flight &#123;</span><br><span class="line">return Flight(</span><br><span class="line">airline: &quot;Aeroflot&quot;,</span><br><span class="line">number: &quot;AF 3245&quot;,</span><br><span class="line">departure: Endpoint(</span><br><span class="line">date: Date(),</span><br><span class="line">airport: Airport(symbol: &quot;AMS&quot;, name: &quot;Schipol&quot;, city: &quot;Amsterdam&quot;)</span><br><span class="line">),</span><br><span class="line">arrival: Endpoint(</span><br><span class="line">date: Date().addingTimeInterval(3 * 60 * 60 + 10 * 60),</span><br><span class="line">airport: Airport(symbol: &quot;SVO&quot;, name: &quot;Sheremetyevo&quot;, city: &quot;Moscow&quot;)</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，为了方便起见，我在<code>View Controller</code>中创建了此数据，但这不是正确的位置。<a href="http://matteomanferdini.com/how-to-persist-data-in-ios-apps-using-property-lists-and-the-correct-architecture-for-handling-persistent-storage/" target="_blank" rel="noopener">数据应来自<code>Model Controller</code></a>，<br>从磁盘或网络检索数据的代码通常驻留在<code>Model Controller</code>中。</p><p>现在<code>View Controller</code>所有需要做的是初始化<code>ViewModel</code>并将其传递给它的<code>FlightCardView</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FlightInfoViewController: UIViewController &#123;</span><br><span class="line">@IBOutlet private weak var cardView: FlightCardView!</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">let flight = createFlight()</span><br><span class="line">cardView.viewModel = FlightCardView.ViewModel(flight: flight)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在我们编写的所有代码中，只有2行属于<code>View Controller</code>。</p><p>与您通常在<code>iOS</code>应用中看到的<code>Massive View Controller</code>完全不同。</p><p><a href="https://github.com/matteom/FlightInfo" target="_blank" rel="noopener">您可以在<code>GitHub</code>上找到此示例的完整代码</a>。</p><h3 id="惰性View-Model的优点"><a href="#惰性View-Model的优点" class="headerlink" title="惰性View Model的优点"></a>惰性<code>View Model</code>的优点</h3><p>正如您所看到的，惰性<code>View Model</code>的优点很多：</p><ul><li>我们尊重<code>MVC</code>的结构和职责划分</li><li><code>View</code>和数据完全脱离开</li><li>无法访问特定视图的内部实现</li><li><code>View Controller</code>具有更少的职责和较少的代码</li><li><code>View</code>可以跨屏幕甚至跨项目重复使用</li><li>扩展<code>View Model</code>有助于为完全不同类型的数据重用相同的<code>View</code></li><li><code>View Model</code>代码是容易测试的，而无需像<code>mock</code>那样测试两次</li></ul><p>原文地址：<a href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" target="_blank" rel="noopener">https://matteomanferdini.com/mvvm-pattern-ios-swift/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragmatic实用主义  </span><br><span class="line">approach 接近,方法  </span><br><span class="line">controversy 论战  </span><br><span class="line">shortcoming 缺点  </span><br><span class="line">definitely 肯定的  </span><br><span class="line">functional 有用的，实用的  </span><br><span class="line">concrete 实在的，具体的，混泥土  </span><br><span class="line">violate 违反，违背  </span><br><span class="line">interpret 解释，说明，翻译  </span><br><span class="line">dictate 指示，指定，指令</span><br><span class="line">extensively 广大地</span><br><span class="line">discern 区分，辨别</span><br><span class="line">trivial 不重要的，琐碎的</span><br><span class="line">populate 居住于，构成人口</span><br><span class="line">explicitly 明白地,明确地</span><br><span class="line">optimal 最理想的，最佳的</span><br><span class="line">impact 影响，冲击</span><br><span class="line">derive 源于，得到</span><br><span class="line">aim 针对，以···为目标</span><br><span class="line">accurate 精准的，准确的</span><br><span class="line">vocal 口头的</span><br><span class="line">proponent 支持者，拥护者</span><br><span class="line">roundup 综述，集拢</span><br><span class="line">skeptical 怀疑性的</span><br><span class="line">implication 影响</span><br><span class="line">downside 下降趋势，缺点</span><br><span class="line">inherently 天性地,固有地</span><br><span class="line">problematic 成问题的，有疑问的</span><br><span class="line">contemplate 深思, 细想</span><br><span class="line">intricate 错综复杂的</span><br><span class="line">can of worms 会造成更多问题</span><br><span class="line">pandora&apos;s box 潘多拉盒子,灾难之源</span><br><span class="line">paradigm 范例</span><br><span class="line">incidentally 偶然地, 不经意地</span><br><span class="line">beast 野兽</span><br><span class="line">illustrate 说明, 阐明</span><br><span class="line">concept 概念，观念</span><br><span class="line">disjoint 解体，使脱臼</span><br><span class="line">hierarchy 等级制度</span><br><span class="line">visualize 形象化, 设想</span><br><span class="line">sole  唯一的，仅有的</span><br><span class="line">separately 分别地，个别地</span><br><span class="line">restriction 约束，限制</span><br><span class="line">reside 居住，定居</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
            <tag> MVVM </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2016/05/20/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2016/05/20/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-‘-‘标题-类-Setext-形式"><a href="#1-‘-‘标题-类-Setext-形式" class="headerlink" title="1. ‘=/-‘标题 (类 Setext 形式)"></a>1. ‘=/-‘标题 (类 Setext 形式)</h2><blockquote><h1 id="Setext-1级标题"><a href="#Setext-1级标题" class="headerlink" title="Setext 1级标题  "></a>Setext 1级标题  </h1><h2 id="Setext-2级标题"><a href="#Setext-2级标题" class="headerlink" title="Setext 2级标题  "></a>Setext 2级标题  </h2></blockquote><p>类 Setext 形式是用底线的形式，利用 <strong>等号(=)</strong> 表示最高阶标题 和 <strong>减号(-)</strong> 表示第二阶标题<br>任何数量的 <strong>=</strong> 和 <strong>-</strong> 都可以有效果。  </p><pre><code>This is an H1=============This is an H2-------------</code></pre><h2 id="2-‘-’标题-类-Atx-形式"><a href="#2-‘-’标题-类-Atx-形式" class="headerlink" title="2. ‘#’标题 (类 Atx 形式)"></a>2. ‘#’标题 (类 Atx 形式)</h2><blockquote><h1 id="Atx-1级标题"><a href="#Atx-1级标题" class="headerlink" title="Atx 1级标题"></a>Atx 1级标题</h1><h2 id="Atx-2级标题"><a href="#Atx-2级标题" class="headerlink" title="Atx 2级标题"></a>Atx 2级标题</h2><h3 id="Atx-3级标题"><a href="#Atx-3级标题" class="headerlink" title="Atx 3级标题"></a>Atx 3级标题</h3><h4 id="Atx-4级标题"><a href="#Atx-4级标题" class="headerlink" title="Atx 4级标题"></a>Atx 4级标题</h4><h5 id="Atx-5级标题"><a href="#Atx-5级标题" class="headerlink" title="Atx 5级标题"></a>Atx 5级标题</h5><h6 id="Atx-6级标题"><a href="#Atx-6级标题" class="headerlink" title="Atx 6级标题"></a>Atx 6级标题</h6></blockquote><p>类 Atx 形式则是在行首插入 1～6 个 <strong>#</strong> ，对应到标题 1～6 阶  </p><pre><code>非闭合方式：# 这是 H1## 这是 H2###### 这是 H6闭合方式（首尾对称）：# 这是 H1 ### 这是 H2 ######## 这是 H6 ######     </code></pre><h2 id="3-斜体"><a href="#3-斜体" class="headerlink" title="3. 斜体"></a>3. 斜体</h2><blockquote><ul><li><em>1个星号</em></li><li><em>1个下划线</em></li></ul></blockquote><p>首尾用 1 个 <strong>星号( * )</strong> 或者 <strong>下划线( _ )</strong> 包含一段文本</p><pre><code>*身正不怕影子斜*_身正不怕影子斜_</code></pre><h2 id="4-粗体"><a href="#4-粗体" class="headerlink" title="4. 粗体"></a>4. 粗体</h2><blockquote><ul><li><strong>2个星号</strong></li><li><strong>2个下划线</strong></li></ul></blockquote><p>首尾用 2 个 <strong>星号( * )</strong> 或者 <strong>下划线( _ )</strong> 包含一段文本</p><pre><code>**粗不粗**__粗不粗__</code></pre><h2 id="5-粗斜体"><a href="#5-粗斜体" class="headerlink" title="5. 粗斜体"></a>5. 粗斜体</h2><blockquote><ul><li><strong><em>3个星号</em></strong></li><li><strong><em>3个下划线</em></strong></li></ul></blockquote><p>首尾用 3 个 <strong>星号( * )</strong> 或者 <strong>下划线( _ )</strong> 包含一段文本</p><pre><code>***又粗又斜有木有***___又粗又斜有木有___</code></pre><h2 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. 无序列表</h2><blockquote><ul><li>无序列表1</li></ul><ul><li>无序列表2</li></ul><ul><li>无序列表3  </li></ul></blockquote><p>无序列表使用 <strong>星号( * )</strong> 、<strong>加号( + )</strong> 或是 <strong>减号( - )</strong> 作为列表标记</p><pre><code>*   Red*   Green*   Blue等同于：+   Red+   Green+   Blue也等同于：-   Red-   Green-   Blue</code></pre><h2 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7. 有序列表"></a>7. 有序列表</h2><blockquote><ol><li>有序立标1</li><li>有序列表2</li><li>有序列表3</li></ol></blockquote><p>有序列表则使用数字接着一个英文句点：<strong>“1.”</strong> <strong>“2.”</strong> <strong>“3.”</strong></p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><h2 id="8-链接"><a href="#8-链接" class="headerlink" title="8. 链接"></a>8. 链接</h2><blockquote><p><a href="http://www.markdown.cn" target="_blank" rel="noopener">Markdown</a></p></blockquote><p>格式：[链接显示的文字](URL地址)</p><pre><code>例如：[Markdown](http://www.markdown.cn)</code></pre><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h2><blockquote><figure class="image-box">                <img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=a4e83ab404d79123f4ed9c26cc5d32e7/7c1ed21b0ef41bd5c306824859da81cb39db3d30.jpg" alt="我是一张快乐的图片" title="" class="">                <p>我是一张快乐的图片</p>            </figure></blockquote><p>格式：![图片的替代文字](图片地址 “可选文字”)</p><pre><code>例如：![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/              w%3D268%3Bg%3D0/sign=79cf53f2074f78f0800b9df5410a6d68/              00e93901213fb80ef9ceac7132d12f2eb938947d.jpg)</code></pre><h2 id="10-引用（Blockquote）"><a href="#10-引用（Blockquote）" class="headerlink" title="10. 引用（Blockquote）"></a>10. 引用（Blockquote）</h2><h5 id="普通区块引用"><a href="#普通区块引用" class="headerlink" title="普通区块引用"></a>普通区块引用</h5><blockquote><p>别人笑我太疯癫<br>  我笑他人看不穿<br>  不见武林豪杰墓<br>  无花无酒锄作田  </p></blockquote><pre><code>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式，自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.  Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</code></pre><h5 id="区块引用可以嵌套（引用内引用）"><a href="#区块引用可以嵌套（引用内引用）" class="headerlink" title="区块引用可以嵌套（引用内引用）"></a>区块引用可以嵌套（引用内引用）</h5><blockquote><p>别人笑我太疯癫，<br>  我笑他人看不穿，<br>  不见武林豪杰墓，<br>  无花无酒锄作田</p><blockquote><p>你是唐伯虎？</p></blockquote><p>哇呀呀呀呀~，好！实不相瞒，小弟我就是人称玉树临风胜潘安，一朵梨花压海棠的小淫虫周伯通！</p></blockquote><pre><code>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><h5 id="区块内使用其他的-Markdown-语法"><a href="#区块内使用其他的-Markdown-语法" class="headerlink" title="区块内使用其他的 Markdown 语法"></a>区块内使用其他的 Markdown 语法</h5><blockquote><h6 id="我是被块引用的标题。"><a href="#我是被块引用的标题。" class="headerlink" title="我是被块引用的标题。"></a>我是被块引用的标题。</h6><ol><li>我是被块引用的列表1。</li><li>我是被块引用的列表2。</li></ol><p>什么？块引用还能引用代码：</p><pre><code>void blockquoteFunction() { printf &quot;我就是被块引用的代码&quot;;}</code></pre></blockquote><pre><code>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：&gt; ## 这是一个标题。&gt; &gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><h2 id="11-代码"><a href="#11-代码" class="headerlink" title="11. 代码"></a>11. 代码</h2><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><blockquote><p>一个简单的函数：<code>void main() { print &quot;Hello, markdown!&quot;; }</code>，在同一行就可以写完</p></blockquote><p>如果要标记一小段行内代码，你可以用 <strong>反引号( ` )</strong> 把它包起来  </p><pre><code>一个简单的函数：`void main() { print &quot;Hello, markdown!&quot;; }`，在同一行就可以写完</code></pre><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>如果要标记多行代码，你可以用3个 <strong>反引号( ` )</strong> 来开启和结束代码区段  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">print &quot;Hello, markdown!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><p>使用 1 个制表符建立代码区块  </p><pre><code>void main() {    print &quot;Hello, markdown!&quot;;}</code></pre><h4 id="方式4"><a href="#方式4" class="headerlink" title="方式4"></a>方式4</h4><p>缩进 4 个空格建立代码区块</p><pre><code>void main() {    print &quot;Hello, markdown!&quot;;}</code></pre><h2 id="12-表格"><a href="#12-表格" class="headerlink" title="12. 表格"></a>12. 表格</h2><blockquote><p>最常见的Markdown格式选项和键盘快捷键(引用自百度百科)</p></blockquote><table><thead><tr><th>&gt; 输出后的效果</th><th style="text-align:center">Markdown</th><th style="text-align:right">快捷键</th></tr></thead><tbody><tr><td>Bold</td><td style="text-align:center"><strong>text</strong></td><td style="text-align:right">Ctrl/⌘ + B</td></tr><tr><td>Emphasize</td><td style="text-align:center"><em>text</em></td><td style="text-align:right">Ctrl/⌘ + I</td></tr><tr><td>Link</td><td style="text-align:center">[title](http://)</td><td style="text-align:right">Ctrl/⌘ + K</td></tr><tr><td>Inline Code</td><td style="text-align:center"><code>code</code></td><td style="text-align:right">Ctrl/⌘ + Shift + K</td></tr><tr><td>Image</td><td style="text-align:center">![alt](http://)</td><td style="text-align:right">Ctrl/⌘ + Shift + I</td></tr><tr><td>List</td><td style="text-align:center">* item</td><td style="text-align:right">Ctrl + L</td></tr><tr><td>Blockquote</td><td style="text-align:center">&gt; quote</td><td style="text-align:right">Ctrl + Q</td></tr><tr><td>H1</td><td style="text-align:center"># Heading</td><td style="text-align:right"></td></tr><tr><td>H2</td><td style="text-align:center">## Heading</td><td style="text-align:right">Ctrl/⌘ + H</td></tr><tr><td>H3</td><td style="text-align:center">### Heading</td><td style="text-align:right">Ctrl/⌘ + H (x2)</td></tr></tbody></table><p>表格格式如下，用 &gt;=3 个 <strong>减号( - )</strong> 分割表头和内容，每一列用 <strong>或( | )</strong> 分割。<br>  默认居左，居中在分割线 <strong>( — )</strong> 两边加上 <strong>英文冒号( : )</strong>，居右在分割线 <strong>( — )</strong> 右边加上 <strong>英文冒号( : )</strong></p><pre><code>表头1     | 表头2           | 表头3---      | :-------------: | ----:默认居左   | 居中 :---:      | 居右 ---:居左 :--- | 居中 :---:      | 居右 ---:</code></pre><h2 id="13-转义符-反斜杠"><a href="#13-转义符-反斜杠" class="headerlink" title="13. 转义符 反斜杠( \ )"></a>13. 转义符 <strong>反斜杠( \ )</strong></h2><p>Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜杠`   反引号*   星号_   下划线{}  花括号[]  方括号()  括弧#   井号+   加号-   减号.   英文句点!   感叹号</code></pre><h2 id="14-分隔线"><a href="#14-分隔线" class="headerlink" title="14. 分隔线"></a>14. 分隔线</h2><blockquote><p>我是一个快乐的句子，我下面有好多线。</p><hr><hr><hr><hr><hr></blockquote><p>用三个以上的 <strong>星号( * )</strong>、<strong>加号( + )</strong> 或是 <strong>下划线( _ )</strong> 来建立一个分隔线。  </p><pre><code>行内不能有其他内容，你也可以在星号或是减号中间插入空格，下面每种写法都可以建立分隔线：**** * *******_ _ _______</code></pre>]]></content>
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Eden Huang</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>@card{</p><p><strong>姓名</strong>：黄聪<br><strong>标签</strong>：iOS、Swift、Flutter、Dart、JS、Java、微信小程序<br><strong>邮箱</strong>：<a href="mailto:huangcong520@icloud.com" target="_blank" rel="noopener">huangcong520@icloud.com</a></p><p>@right{</p><p><strong>个人资料</strong></p><p>}</p><p>}</p><p>@card{</p><p><strong>本博客主题</strong>：<a href="https://github.com/codefine/hexo-theme-mellow" target="_blank" rel="noopener">hexo-theme-mellow</a></p><p>}</p><hr><p>@timeline{</p><h5 id="工作履历"><a href="#工作履历" class="headerlink" title="工作履历"></a>工作履历</h5><p>@item{</p><h6 id="2016-09"><a href="#2016-09" class="headerlink" title="2016.09"></a>2016.09</h6><p><strong>神马专车</strong><br>神马专车</p><p>}</p><p>@item{</p><h6 id="2014-10-2016-05"><a href="#2014-10-2016-05" class="headerlink" title="2014.10 ~ 2016.05"></a>2014.10 ~ 2016.05</h6><p><strong>地利集团</strong><br>农丰网</p><p>}</p><p>@item{</p><h6 id="2013-04-2014-10"><a href="#2013-04-2014-10" class="headerlink" title="2013.04 ~ 2014.10"></a>2013.04 ~ 2014.10</h6><p><strong>图丰信息（成都）有限责任公司</strong><br>Stamigo</p><p>}</p><p>@item{</p><h6 id="2011-12-2013-04"><a href="#2011-12-2013-04" class="headerlink" title="2011.12 ~ 2013.04"></a>2011.12 ~ 2013.04</h6><p><strong>Myriad Group</strong><br>Pivot、Messager</p><p>}</p><p>@item{</p><h6 id="2011-06-2011-11"><a href="#2011-06-2011-11" class="headerlink" title="2011.06 ~ 2011.11"></a>2011.06 ~ 2011.11</h6><p><strong>成都融创天下科技有限公司</strong><br>监控摄像头客户端</p><p>}</p><p>}</p><hr><h3 id="我的朋友们-排名不分先后"><a href="#我的朋友们-排名不分先后" class="headerlink" title="我的朋友们(排名不分先后)"></a><strong>我的朋友们(排名不分先后)</strong></h3><p>@column-3{</p><p>@card{</p><p>@center{</p><p><a href="http://wwhy.tech/" target="_blank" rel="noopener">成都老刘</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>}</p><hr><h3 id="大佬们"><a href="#大佬们" class="headerlink" title="大佬们"></a><strong>大佬们</strong></h3><p>@column-3{</p><p>@card{</p><p>@center{</p><p><a href="https://onevcat.com/" target="_blank" rel="noopener">onevcat</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>@card{</p><p>@center{</p><p><a href="http://blog.devtang.com/" target="_blank" rel="noopener">唐巧</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>@card{</p><p>@center{</p><p><a href="https://blog.ibireme.com/" target="_blank" rel="noopener">YYKit作者</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>}</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>自定义页面演示</title>
      <link href="/custom/index.html"/>
      <url>/custom/index.html</url>
      <content type="html"><![CDATA[<h1 id="双栏结构"><a href="#双栏结构" class="headerlink" title="双栏结构"></a>双栏结构</h1><p>@column-2{</p><p>@card{</p><h1 id="左"><a href="#左" class="headerlink" title="左"></a>左</h1><p>}</p><p>@card{</p><h1 id="右"><a href="#右" class="headerlink" title="右"></a>右</h1><p>}</p><p>}</p><h1 id="控制文本对齐方式的三栏结构"><a href="#控制文本对齐方式的三栏结构" class="headerlink" title="控制文本对齐方式的三栏结构"></a>控制文本对齐方式的三栏结构</h1><p>@column-3{</p><p>@card{</p><p>左</p><p>}</p><p>@card{</p><p>@center{</p><p>中</p><p>}</p><p>}</p><p>@card{</p><p>@right{</p><p>右</p><p>}</p><p>}</p><p>}</p><p>@timeline{</p><h5 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h5><p>@item{</p><h6 id="11月6日"><a href="#11月6日" class="headerlink" title="11月6日"></a>11月6日</h6><p>为 <code>Card theme</code> 添加 <code>page layout</code>。<br>第二行测试</p><p>}</p><p>@item{</p><h6 id="11月20日"><a href="#11月20日" class="headerlink" title="11月20日"></a>11月20日</h6><p>另一个 Time line .<br>第二行测试</p><p>}</p><p>@item{</p><h6 id="11月20日-1"><a href="#11月20日-1" class="headerlink" title="11月20日"></a>11月20日</h6><p>还有一个 Time line .<br>第二行测试</p><p>}</p><p>}</p>]]></content>
    </entry>
    
    <entry>
      <title>阅读</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[<p>@card{</p><h3 id="在读书籍"><a href="#在读书籍" class="headerlink" title="在读书籍"></a><strong>在读书籍</strong></h3><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img3.doubanio.com/view/subject/l/public/s25648004.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论（原书第3版）》</a></p><p>}</p><p><strong>内容简介：</strong><br>在有关算法的书中，有一些叙述非常严谨，但不够全面；另一些涉及了大量的题材，但又缺乏严谨性。本书将严谨性和全面性融为一体，深入讨论各类算法，并着力使这些算法的设计和分析能为各个层次的读者接受。全书各章自成体系，可以作为独立的学习单元；算法以英语和伪代码的形式描述，具备初步程序设计经验的人就能看懂；说明和解释力求浅显易懂，不失深度和数学严谨性。</p><p>}</p><p>}</p><hr><p>@card{</p><h3 id="已读书籍"><a href="#已读书籍" class="headerlink" title="已读书籍"></a><strong>已读书籍</strong></h3><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img3.doubanio.com/view/subject/l/public/s28100915.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">《Objective-C高级编程》</a></p><p>}</p><p><strong>内容简介：</strong><br>本书在苹果公司公开的源代码基础上，深入剖析了对应用于内存管理的ARC 以及应用于多线程开发的Blocks 和GCD。这些新技术看似简单，实则非常容易成为技术开发的陷阱，开发者仅靠阅读苹果公司的文档是不够的。<br>本书适合有一定基础的iOS 开发者阅读。</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="https://img1.doubanio.com/view/subject/l/public/s27552168.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="noopener">《Effective Objective-C 2.0》</a></p><p>}</p><p><strong>内容简介：</strong><br>《effective objective-c 2.0：编写高质量ios与os x代码的52个有效方法》是世界级c++开发大师scott meyers亲自担当顾问编辑的“effective software development series”系列丛书中的新作，amazon全五星评价。从语法、接口与api设计、内存管理、框架等7大方面总结和探讨了objective-c编程中52个鲜为人知和容易被忽视的特性与陷阱。书中包含大量实用范例代码，为编写易于理解、便于维护、易于扩展和高效的objective-c应用提供了解决方案。</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img1.doubanio.com/view/subject/l/public/s6908318.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></p><p>}</p><p><strong>内容简介：</strong><br>本书通篇都是以情景对话的形式，用多个小故事或编程示例来组织讲解GOF(设计模式的经典名著——Design Patterns:Elements of Reusable Object-Oriented Software，中译本名为《设计模式——可复用面向对象软件的基础》的四位作者EIich Gamma、Richard Helm、Ralph Johnson，以及John Vlissides，这四人常被称为Gang of Four，即四人组，简称GoF)总结的23个设计模式。</p><p>}</p><p>}</p><hr><p>@card{</p><h3 id="待读书籍"><a href="#待读书籍" class="headerlink" title="待读书籍"></a><strong>待读书籍</strong></h3><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img1.doubanio.com/view/subject/l/public/s1495029.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全（第2版）》</a></p><p>}</p><p><strong>内容简介：</strong><br>这是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。</p><p>}</p><p>}</p>]]></content>
    </entry>
    
    <entry>
      <title>study</title>
      <link href="/study/index.html"/>
      <url>/study/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Hexo Themes</title>
      <link href="/themes/index.html"/>
      <url>/themes/index.html</url>
      <content type="html"><![CDATA[<p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-anisina.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Haojen/hexo-theme-Anisina" target="_blank" rel="noopener">hexo-theme-Anisina</a><br><a href="https://haojen.github.io/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-claudia.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Haojen/hexo-theme-Claudia" target="_blank" rel="noopener">hexo-theme-Claudia</a><br><a href="https://haojen.github.io/Claudia-theme-blog/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-melody.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a><br><a href="https://molunerfinn.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-miho.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/WongMinHo/hexo-theme-miho" target="_blank" rel="noopener">hexo-theme-miho</a><br><a href="https://blog.minhow.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-vexo.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/yanm1ng/hexo-theme-vexo" target="_blank" rel="noopener">hexo-theme-vexo</a><br><a href="https://yanm1ng.github.io/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-paperbox.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank" rel="noopener">hexo-theme-paperbox</a><br><a href="http://www.sun11.me/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-diaspora.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Fechin/hexo-theme-diaspora" target="_blank" rel="noopener">hexo-theme-diaspora</a><br><a href="http://fech.in/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-ztopic.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/wa-ri/hexo-theme-ztopic" target="_blank" rel="noopener">hexo-theme-ztopic</a><br><a href="http://zccblog.cn/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-indigo.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a><br><a href="https://www.imys.net/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-mellow.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/codefine/hexo-theme-mellow" target="_blank" rel="noopener">hexo-theme-mellow</a><br><a href="http://blog.lujingtao.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-material.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">hexo-theme-material</a><br><a href="https://blog.viosey.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-spfk.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/luuman/hexo-theme-spfk" target="_blank" rel="noopener">hexo-theme-spfk</a><br><a href="https://luuman.github.io/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p>]]></content>
    </entry>
    
  
</search>
