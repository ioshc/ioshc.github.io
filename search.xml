<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>iOS 11 中 UIBarButtonItem 的变化</title>
      <link href="/2017/11/09/iOS%2011%20%E4%B8%AD%20UIBarButtonItem%20%E7%9A%84%E5%8F%98%E5%8C%96/"/>
      <url>/2017/11/09/iOS%2011%20%E4%B8%AD%20UIBarButtonItem%20%E7%9A%84%E5%8F%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>随着 iOS 11 和 Xcode 9 的发布，导航栏<code>UINavigationBar</code> 里面的控件 <code>UIBarButtonItem</code> 有一些变化，下面我们一起看看有哪些变化。</p><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><ul><li><code>UIBarButtonItems</code> 的custom view的点击区域更小了</li><li>返回按钮的点击区域也更小了</li><li>如果上一个屏幕的 title 有变化，则返回按钮的 label 不再自动更新（iOS 10 前会自动更新）</li><li><code>UIBarButtonSystemItemFixedSpace</code> 类型的 <code>UIBarButtonItem</code> 现在至少有 8 个点的最小宽度，负数的 width 不再生效</li><li>重写 <code>alignmentRectInsets</code> 可能会导致 custom views 超出点击区域</li></ul><p>下面会详细的讲解上面几点变化。</p><h3 id="点击区域-Tap-Areas"><a href="#点击区域-Tap-Areas" class="headerlink" title="点击区域(Tap Areas)"></a>点击区域(Tap Areas)</h3><p>我们假设有一个 <strong>iOS 10</strong> 程序，其中包含两个有 custom view 的 <code>UIBarButtonItem</code>。然后我们使用 <code>Debug View Hierarchy</code> 去检查 custom 的真实大小。</p><figure class="image-box">                <img src="2017-11-09/1.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>他们的点击区域实际上会更大，和下面的红色方块区域大小一致。</p><figure class="image-box">                <img src="2017-11-09/2.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>然而在 <strong>iOS 11</strong> 上，显示的效果和上面的效果就不同了。点击区域大小和 custom view 的大小一致。</p><figure class="image-box">                <img src="2017-11-09/3.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>在 <strong>iOS 11</strong> 上，这种点击区域的大小的确会使得用户很难点击。为了扩大点击区域，custom view 的需要扩大边距。我们可以创建一个拥有最小的size 约束的 Wrapper view。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WrapperView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> minimumSize: <span class="type">CGSize</span> = <span class="type">CGSize</span>(width: <span class="number">44.0</span>, height: <span class="number">44.0</span>)</span><br><span class="line">    <span class="keyword">let</span> underlyingView: <span class="type">UIView</span></span><br><span class="line">    <span class="keyword">init</span>(underlyingView: <span class="type">UIView</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.underlyingView = underlyingView</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: underlyingView.bounds)</span><br><span class="line"></span><br><span class="line">        underlyingView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">        addSubview(underlyingView)</span><br><span class="line"></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            underlyingView.leadingAnchor.constraint(equalTo: leadingAnchor),</span><br><span class="line">            underlyingView.trailingAnchor.constraint(equalTo: trailingAnchor),</span><br><span class="line">            underlyingView.topAnchor.constraint(equalTo: topAnchor),</span><br><span class="line">            underlyingView.bottomAnchor.constraint(equalTo: bottomAnchor),</span><br><span class="line">            heightAnchor.constraint(greaterThanOrEqualToConstant: minimumSize.height),</span><br><span class="line">            widthAnchor.constraint(greaterThanOrEqualToConstant: minimumSize.width)</span><br><span class="line">        ])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="2017-11-09/4.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="返回按钮-Back-Button"><a href="#返回按钮-Back-Button" class="headerlink" title="返回按钮(Back Button)"></a>返回按钮(Back Button)</h3><h4 id="点击区域-Tap-Area"><a href="#点击区域-Tap-Area" class="headerlink" title="点击区域(Tap Area)"></a>点击区域(Tap Area)</h4><p>当 view controller 的 title 很长的时候，iOS 11 上的返回按钮点击区域会变得更小。</p><p>在 iOS 10 上的返回按钮有一个比较大的最小宽度，利于用户点击。</p><figure class="image-box">                <img src="2017-11-09/5.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>然而在 iOS 11 上，返回按钮的点击区域变得很小。更糟糕的是 view controller 的 title，有时看起来像是返回按钮的 label。</p><figure class="image-box">                <img src="2017-11-09/6.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h4 id="动态更新-Label"><a href="#动态更新-Label" class="headerlink" title="动态更新(Label)"></a>动态更新(Label)</h4><p>iOS 11 上面另外一个更新是返回按钮的 label。</p><p>举个例子，假设有一个能够自动更新 title 的 <code>First(4)</code> 页面 (UIViewController),</p><figure class="image-box">                <img src="2017-11-09/7.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>界面从 <code>First(4)</code> 页面 push 到 <code>Second</code> 页面，</p><figure class="image-box">                <img src="2017-11-09/8.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>在 iOS 10 上，当 <code>First(4)</code>的 title 从 First(4) 变化到 First(6) 之后，返回按钮也变成了 First(6)，</p><figure class="image-box">                <img src="2017-11-09/9.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>而在 iOS 11 上，返回按钮的 label 并没有自动更新，而是保持不变。</p><figure class="image-box">                <img src="2017-11-09/10.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="自动布局-Auto-Layout"><a href="#自动布局-Auto-Layout" class="headerlink" title="自动布局(Auto Layout)"></a>自动布局(Auto Layout)</h3><p><code>UINavigationBar</code> 现在能够使用自动布局（Auto Layout）来布局它的 subviews（包括 custom views）。在今年的 WWDC上中的 <a href="https://developer.apple.com/videos/play/wwdc2017/204/" target="_blank" rel="noopener">Updating Your Apps for iOS 11</a> 里面有提到。</p><p>在 iOS 11 中，我们能够从 <code>Debug View Hierarchy</code> 检查 <code>UINavigationBar</code> 看到，<code>UINavigationBar</code> 内部的 buttons 都被放置在一个 stack view 中。</p><figure class="image-box">                <img src="2017-11-09/11.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>当我们正确的实现了 custom view 的 <code>sizeThatFits</code> 和 <code>intrinsicContentSize</code>，<code>UINavigationBar</code>也会如以前那样工作正常。</p><p>但是，需要注意的是，当我们把custom view 的 <code>translatesAutoresizingMaskIntoConstraints</code> 设成 <code>false</code>，在 iOS 10（如果你的 App 还支持 iOS 10的话）上，可能出现一些莫名其妙的问题。比如可能导致custom view 的 top-left 方向布局错位。这种情况下，一个简单的保护代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let customView = createCustomView()</span><br><span class="line">if #available(iOS 11, *) &#123;</span><br><span class="line">    customView.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">&#125;</span><br><span class="line">navigationItem.rightBarButtonItem = UIBarButtonIte(customView: customView)</span><br></pre></td></tr></table></figure><h3 id="自定义对齐-Custom-Alignment"><a href="#自定义对齐-Custom-Alignment" class="headerlink" title="自定义对齐(Custom Alignment)"></a>自定义对齐(Custom Alignment)</h3><p>很多时候，我们想能够自由的控制 custom <code>UIBarButtonItem</code> 的布局（对齐），特别是和屏幕两边的边距大小。在 iOS 10（及以前）来说，我们经常用到两种小技巧：</p><ul><li>使用fixed space item，即<code>UIBarButtonItem(barButtonSystemItem: .fixedSpace …)</code>，并且赋值一个负数，比如-15</li><li>重写 custom view 的 <code>alignmentRectInsets</code></li></ul><p>但是在 iOS 11 上，上面两个方法都有点变化，第一个办法已经失效，而第二个办法也有点问题。</p><h4 id="Fixed-Space-Items"><a href="#Fixed-Space-Items" class="headerlink" title="Fixed Space Items"></a>Fixed Space Items</h4><p>当我们使用 custom view 的时候， 默认的边距是16个点，</p><figure class="image-box">                <img src="2017-11-09/12.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>假设我们想将边距减少到 8 个点，那么在 iOS 10 上面，我们需要设置fixed space <code>UIBarButtonItem</code> 的宽度为 -8 就可以达到我们想要的效果。</p><figure class="image-box">                <img src="2017-11-09/13.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let spacer = UIBarButtonItem(barButtonSystemItem: .fixedSpace, target: nil, action: nil)</span><br><span class="line">spacer.width = -8</span><br><span class="line">let barButtonsItems = [</span><br><span class="line">    spacer,</span><br><span class="line">    UIBarButtonItem(customView: createCustomButton()),</span><br><span class="line">    UIBarButtonItem(customView: createCustomButton())</span><br><span class="line">]</span><br><span class="line">navigationItem.rightBarButtonItems = barButtonItems</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="2017-11-09/14.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>然而在 iOS 11 上，修改fixed space <code>UIBarButtonItem</code> 的宽度为 -8 会不生效。</p><h4 id="Alignment-Rect-Insets"><a href="#Alignment-Rect-Insets" class="headerlink" title="Alignment Rect Insets"></a>Alignment Rect Insets</h4><p>而重写 custom view 的 <code>alignmentRectInsets</code>，在 iOS 10 上面也能够修改布局边距</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CustomView: UIView &#123;</span><br><span class="line">    var alignmentRectInsetsOverride: UIEdgeInsets?</span><br><span class="line">    override var alignmentRectInsets: UIEdgeInsets &#123;</span><br><span class="line">        return alignmentRectInsetsOverride ?? super.alignmentRectInsets</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 <code>alignmentRectInsets</code> 的值为 UIEdgeInsets(top: 0, left: -8, bottom: 0, right: 8)，也能够和前面的修改起到相同的作用</p><figure class="image-box">                <img src="2017-11-09/15.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>上面的代码在 iOS 11 上面依然能够起到作用，但是有一个小的问题是，item 里面有一小部分超出了 stack view 的范围。超出的区域不能点击，也就意味着点击区域变小了。</p><figure class="image-box">                <img src="2017-11-09/16.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h4 id="Workaround"><a href="#Workaround" class="headerlink" title="Workaround"></a>Workaround</h4><p>根据前面<a href="#fixed-space-items">fixed space的例子</a>，我们发现相对于未使用 custom view 的情况，边距有所变小。</p><figure class="image-box">                <img src="2017-11-09/17.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>当我们未使用 custom view 的时候，边距到屏幕边缘是 8 个点</p><figure class="image-box">                <img src="2017-11-09/18.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>当我们使用了 custom view 的时候，边距到屏幕是 16 个点</p><figure class="image-box">                <img src="2017-11-09/19.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>根据上面的发现，我们的目标是：让 custom view 的边距在 iOS 11 上面依然是 8 个点。添加一个 <code>fix space item</code> 将会使得内部的 stack view 减少边距，那么修改 <code>alignmentRectInsets</code> 的值去移动 <code>custom view</code> 的 frame，可以使内部的 stack view 对齐。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func alignedBarButtonItems() -&gt; [UIBarButtonItem] &#123;</span><br><span class="line">    let spacer = UIBarButtonItem(barButtonSystemItem: .fixedSpace, target: nil, action: nil)</span><br><span class="line">    spacer.width = 8</span><br><span class="line">    let barButtonsItems = [</span><br><span class="line">        spacer,</span><br><span class="line">        UIBarButtonItem(customView: createCustomButton(offset: spacer.width)),</span><br><span class="line">        UIBarButtonItem(customView: createCustomButton(offset: spacer.width)),</span><br><span class="line">        ]</span><br><span class="line">    return barButtonsItems</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createCustomButton(offset: CGFloat = 0) -&gt; UIButton &#123;</span><br><span class="line">    let button = CustomButton(frame: CGRect(x:0, y: 0, width: 24, height: 24))</span><br><span class="line">    button.alignmentRectInsetsOverride = UIEdgeInsets(top: 0, left: -offset, bottom: 0, right: offset)</span><br><span class="line">    button.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">    return button</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-box">                <img src="2017-11-09/20.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>目前来说，这个 workaround 只能将边距设置为 8，如果我们将这个值设为一个更小的值，那么custom view 依然会超出 stack view。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.matrixprojects.net/p/uibarbuttonitem-ios11/" target="_blank" rel="noopener">UIBarButtonItem &amp; iOS 11</a></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS11 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>这些__attribute__的知识你应该知道</title>
      <link href="/2017/10/03/%E8%BF%99%E4%BA%9B__attribute__%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/"/>
      <url>/2017/10/03/%E8%BF%99%E4%BA%9B__attribute__%E7%9A%84%E7%9F%A5%E8%AF%86%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93/</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>最近查看在网上发现了个有趣的小玩意<code>__attribute__</code>, 也就是 Clang Attributes，这是一个编译器提供的功能，能够让我向编译器指定一些特殊的功能，比如</p><ul><li><strong>attribute</strong>((deprecated))：描述一个方法已经废弃；</li><li><strong>attribute</strong>((objc_requires_super))：描述子类继承父类的方法时需要调用 super方法；</li><li><strong>attribute</strong>((cleanup(…))): 描述一个变量在作用域结束时能够执行指定方法；</li><li>……</li></ul><p>Clang 编译器提供了很多的 <code>__attribute__</code> 功能，下面会介绍一些 Objective-C 中常用的一些功能。</p><p>可以参考相关的文章 <a href="http://nshipster.com/__attribute__/" target="_blank" rel="noopener">NShipster</a> 和 <a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="noopener">clang-attributes</a>。</p><h3 id="attribute-deprecated"><a href="#attribute-deprecated" class="headerlink" title="__attribute__((deprecated))"></a>__attribute__((deprecated))</h3><p>描述一个<strong>方法</strong>，表明这是一个被废弃的方法，如果有地方在调用，编译器会提示一个警告；并且也提供自定义警告信息，格式如下<strong>attribute</strong>((deprecated(“meesage”)))</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)thisIsADeprecatedMethod __attribute__((deprecated(&quot;This is a deprecated message&quot;)));</span><br></pre></td></tr></table></figure><p>在 Xcode 中，我们编写代码的时候， 编辑器会和 Clang 编译器的预编译系统配合，在我们写代码的时候，就在 IDE 中把警告给显示出来。</p><figure class="image-box">                <img src="2017-10-03/1.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="attribute-objc-boxable"><a href="#attribute-objc-boxable" class="headerlink" title="__attribute__((objc_boxable))"></a>__attribute__((objc_boxable))</h3><p>能够给 struct 和 union 提供快捷的“包装”方式。</p><ol><li>CGRect， CGSize， CGPoint, CGVector 能够使用框架提供的 boxable 快速“包装”；</li><li>自定义 struct 或 union 类型，也可以添加 <strong>attribute</strong>((objc_boxable)) 以支持 boxable 快速“包装”。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CGPoint point = &#123;1, 2&#125;;                     // x = 1, y = 2</span><br><span class="line">CGRect rect1 = &#123;1, 2, 3, 4&#125;;                // x = 1, y = 2, width = 3, height = 4</span><br><span class="line">CGTriangle triange1 = &#123;1, 2, 3, 4, 5, 6&#125;;   // a.x = 1, a.y = 2, b.x = 3, b.y = 4, c.x = 5, c.y = 6</span><br><span class="line">// “包装”需要的数据不够，不够的数据补0</span><br><span class="line">CGSize size = &#123;1&#125;;                          // width = 1, height = 0</span><br><span class="line">// “包装”的 CGRect 中的 CGPoint 需要的数据不够，不够的数据补0</span><br><span class="line">CGRect rect2 = &#123;&#123;1&#125;, &#123;3, 4&#125;&#125;;               // x = 1, y = 0, width = 3, height = 4</span><br><span class="line"></span><br><span class="line">typedef struct __attribute__((objc_boxable)) &#123;</span><br><span class="line">    CGPoint x;</span><br><span class="line">    CGPoint y;</span><br><span class="line">    CGPoint z;</span><br><span class="line">&#125; CGTriangle;</span><br><span class="line"></span><br><span class="line">CGTriangle triange = &#123;1, 2, 3, 4, 5, 6&#125;;</span><br><span class="line">// “包装”的数据多了，最后一条丢掉</span><br><span class="line">CGTriangle triange2 = &#123;1, 2, 3, 4, 5, 6, 7&#125;;// a.x = 1, a.y = 2, b.x = 3, b.y = 4, c.x = 5, c.y = 6</span><br></pre></td></tr></table></figure><p>这里“包装”的方式需要注意：</p><ul><li>可以采用<strong>平铺</strong>，如<code>{1, 2, 3, 4}</code>，也可以采用<strong>嵌套</strong>，如 <code>{ {1, 2}, {3, 4} }</code></li><li>如果“包装”赋值数据的个数比定义的少，则没有赋值的部分全部为0，如<code>CGSize size = {1}; // width = 1, height = 0</code></li><li>如果“包装”赋值数据的个数比定义的多，则多余的部分丢掉。如<code>CGTriangle triange2 = {1, 2, 3, 4, 5, 6, 7};// a.x = 1, a.y = 2, b.x = 3, b.y = 4, c.x = 5, c.y = 6</code></li></ul><figure class="image-box">                <img src="2017-10-03/2.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="attribute-objc-subclassing-restricted"><a href="#attribute-objc-subclassing-restricted" class="headerlink" title="__attribute__((objc_subclassing_restricted))"></a>__attribute__((objc_subclassing_restricted))</h3><p>描述一个<strong>类</strong>是一个不能被继承的类。</p><p>如果定义一个 Father 类，并且使用<code>__attribute__((objc_subclassing_restricted))</code>描述，那么如果一个 Son 类要去继承于 Father，编辑器会在编译器的预编译系统的帮助下，在 IDE 里面就把错误显示出来。</p><figure class="image-box">                <img src="2017-10-03/3.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="attribute-objc-requires-super"><a href="#attribute-objc-requires-super" class="headerlink" title="__attribute__((objc_requires_super))"></a>__attribute__((objc_requires_super))</h3><p>描述一个<strong>子类</strong>继承父类的方法时，需要调用 super，否则给出编译警告。</p><p>如果定义一个 Father 类，里面包含一个 call 方法，并且使用<code>__attribute__((objc_requires_super))</code>描述，那么如果一个 Son 在调用 call 的时候，需要显式的调用[super call]，如果没有调用，那么编辑器会在编译器的预编译系统的帮助下，在 IDE 里面就把警告显示出来。</p><figure class="image-box">                <img src="2017-10-03/4.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="attribute-warn-unused-result"><a href="#attribute-warn-unused-result" class="headerlink" title="__attribute__((warn_unused_result))"></a>__attribute__((warn_unused_result))</h3><p>描述一个<strong>方法</strong>，如果此方法有返回值，但是调用的地方<strong>并未使用返回值</strong>，编译器就会提示一个警告。（编辑器在编译器的预编译系统的帮助下，也会在 IDE 中显示警告）</p><p>如下面 Hippo 类的 bite 方法，使用了 <code>__attribute__((warn_unused_result))</code> 进行描述，在 bite 方法调用的时候没有使用返回值，编译器就就提示了一个警告</p><figure class="image-box">                <img src="2017-10-03/5.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="attribute-cleanup-…"><a href="#attribute-cleanup-…" class="headerlink" title="__attribute__((cleanup(…)))"></a>__attribute__((cleanup(…)))</h3><p>修饰一个<strong>变量</strong>，在它的作用域结束时可以执行一个指定的方法。</p><p>cleanup 是一个用好了就很爽的属性，详细内容可以查看<a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="noopener">黑魔法<strong>attribute</strong>((cleanup))</a></p><h4 id="基本类型变量"><a href="#基本类型变量" class="headerlink" title="基本类型变量"></a>基本类型变量</h4><p>如果一个<strong>临时基本类型变量</strong>，在其超出作用域之后，这个变量会直接调用 cleanup。</p><figure class="image-box">                <img src="2017-10-03/8.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h4 id="对象变量"><a href="#对象变量" class="headerlink" title="对象变量"></a>对象变量</h4><p>如果一个<strong>临时变量对象</strong>，在超出其作用域之后，其临时变量（变量本身）会被释放，但是其指向的对象则会根据他的生命周期来决定是否释放。也就是说：</p><blockquote><ul><li>如果临时变量对象，没有被其他对象持有，那么最后其会先调用 cleanup，然后再调用 dealloc 方法</li><li>如果临时变量对象，被其他对象持有了，那么其只会调用 cleanup，而 dealloc 是不会被调用的。（这是因为临时变量（变量本身）会被释放，但是其指向的对象则会根据他的生命周期来决定是否释放）</li></ul></blockquote><p>下面两个例子可以很好的阐述上面两个观点：</p><figure class="image-box">                <img src="2017-10-03/6.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><p>而下面的 hippo 对象被当前类给持有了，所以 dealloc 是不会调用的，只会调用 cleanup。</p><figure class="image-box">                <img src="2017-10-03/7.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>__attribute__ 提供了很多的编译时功能，恰当的运用这些功能，可以使我们的代码更加灵活。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NSTimer 不用的时候为什么需要调用invalidate？</title>
      <link href="/2017/09/13/NSTimer%20%E4%B8%8D%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8invalidate%EF%BC%9F/"/>
      <url>/2017/09/13/NSTimer%20%E4%B8%8D%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B0%83%E7%94%A8invalidate%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>最近在调试 NSTimer，发现了一些有趣的东西，在此文分析研究一下。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>一个 viewController，持有了一个 timer, 当不需要这个 timer 的时候，能不能只调用 <code>self.timer = nil;</code>？</p><h3 id="什么是-NSTimer？"><a href="#什么是-NSTimer？" class="headerlink" title="什么是 NSTimer？"></a>什么是 NSTimer？</h3><p>根据 Apple 的开源代码 <a href="https://opensource.apple.com/source/CF/CF-1153.18/CFRunLoop.c" target="_blank" rel="noopener">CFRunLoop.c</a> 的定义，NSTimer 对应着一个 __CFRunLoopTimer 的结构体，具体代码如下：</p><h4 id="CFRunLoopTimer"><a href="#CFRunLoopTimer" class="headerlink" title="__CFRunLoopTimer"></a>__CFRunLoopTimer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopTimer &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    uint16_t _bits;</span><br><span class="line">    pthread_mutex_t _lock;</span><br><span class="line">    CFRunLoopRef _runLoop;</span><br><span class="line">    CFMutableSetRef _rlModes;</span><br><span class="line">    CFAbsoluteTime _nextFireDate;</span><br><span class="line">    CFTimeInterval _interval;/* immutable */</span><br><span class="line">    CFTimeInterval _tolerance;          /* mutable */</span><br><span class="line">    uint64_t _fireTSR;/* TSR units */</span><br><span class="line">    CFIndex _order;/* immutable */</span><br><span class="line">    CFRunLoopTimerCallBack _callout;/* immutable */</span><br><span class="line">    CFRunLoopTimerContext _context;/* immutable, except invalidation */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到 <strong>CFRunLoopTimer 里面有一个<code>CFRunLoopRef _runLoop</code>，这个表示 timer 是属于哪一个 runLoop 的，而里面的<code>CFMutableSetRef _rlModes</code>则表示这个 timer 是在 runLoop 的哪些 mode（</strong>CFRunLoopMode） 中生效。</p><p>同时我们也能看到 __CFRunLoopTimer（即 NSTimer） 使用的是 pthread_mutex_t 锁。</p><h4 id="CFRunLoopMode"><a href="#CFRunLoopMode" class="headerlink" title="__CFRunLoopMode"></a>__CFRunLoopMode</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;/* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从 __CFRunLoopMode 的源代码中， 我们可看到里面包含着一个<code>CFMutableArrayRef _timers</code>，也就是说 runLoopMode 有一个存放 timer 的数组，即当我们指定一个 timer 的 runLoopMode 的时候，<code>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]</code>， 会把这个 timer 放入相应的 runLoopMode 对象中。也就是说这个 runLoopMode 对象里面的 _timers 数组，会持有这个 timer 对象。这一点可以从 Xcode 的 Memory Graph中看到<br><figure class="image-box">                <img src="2017-09-13/1.jpg" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><br>当我们不需要一个 timer 的时候，我们是使用 NSTimer 的一个方法 <code>invalidate</code> 来进行解除所有和这个 timer 相关的持有关系。</p><p>同样我们也能看到 __CFRunLoopMode 使用的也是 pthread_mutex_t 锁。</p><h4 id="回答前面的问题"><a href="#回答前面的问题" class="headerlink" title="回答前面的问题"></a>回答前面的问题</h4><p><strong>当我有一个 viewController，持有了一个 timer, 我能不能只调用 <code>self.timer = nil;</code>?</strong></p><blockquote><p>不能，因为 <code>self.timer = nil;</code> 只是解除了 viewController 持有 timer，但是并没有解除 runLoopMode 里面的数组持有 timer 的关系，所以必须调用invalidate来解除所有和 timer 相关的关系。</p></blockquote>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> NSTimer </tag>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面向对象：三大特征、五大原则</title>
      <link href="/2017/08/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E3%80%81%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2017/08/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9A%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E3%80%81%E4%BA%94%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<h3 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><blockquote><p>将对象的属性和细节隐藏起来，只提供公共的访问方式。</p></blockquote><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><blockquote><p>继承是从已有的类派生出新的类，新的类能继承已有类的数据属性和行为，并扩展新的功能。</p></blockquote><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><blockquote><p>同一个实现接口，使用不同的实例而执行不同的操作。</p></blockquote><h3 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a>五大原则</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><blockquote><p>一个类只负责一项职责。</p></blockquote><h4 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h4><blockquote><p>对扩展开放，对修改关闭。</p></blockquote><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><blockquote><p>高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。</p></blockquote><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><blockquote><p>只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。。</p></blockquote><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><blockquote><p>一个类对另外一个类的依赖性应当是建立在最小的接口上的。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS代码规范</title>
      <link href="/2017/07/25/iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2017/07/25/iOS%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      <content type="html"><![CDATA[<h2 id="一-XCode设置"><a href="#一-XCode设置" class="headerlink" title="一. XCode设置"></a>一. XCode设置</h2><ol><li>使用空格而不是制表符 <code>Tab</code>，不要在工程里使用 <code>Tab</code> 键，使用空格来进行缩进。<br> 在 <code>Xcode &gt; Preferences &gt; Text Editing</code> 将 <code>Tab</code> 和自动缩进都设置为 4 个空格。  </li><li>同样的，在 <code>Xcode &gt; Preferences &gt; Text Editing &gt; Page guide at column</code>: 中将最大行长设置为 100 ，过长的一行代码将会导致可读性问题。</li></ol><h2 id="二-整体风格："><a href="#二-整体风格：" class="headerlink" title="二.整体风格："></a>二.整体风格：</h2><ol><li>前缀：解决<code>OC</code>没有命名空间的问题。命名类、协议、常量、枚举、宏定义和<code>typedef</code>结构体时使用前缀</li><li>命名采用英文单词或其组合，采用大小驼峰命名法，应直观可拼读，最好望文知义，切忌使用汉语拼音来命名</li><li>禁止使用连续的下划线（<code>variable_name</code> 与 <code>ariable__name</code> 很难区分）</li><li><p>通知常用于在模块间传递消息，所以通知要尽可能地表示出发生的事件，</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">通知的命名范式是：</span><br><span class="line"></span><br><span class="line">[ 触发通知的类名 ] + [Did | Will] + [ 动作 ] + Notification</span><br><span class="line">UIApplicationDidEnterBackgroundNotification</span><br><span class="line">UIApplicationWillEnterForegroundNotification</span><br></pre></td></tr></table></figure></li><li><p><code>if</code>条件语句只有一行代码，不得省略<code>{}</code>，只有当条件语句和执行代码一行时才能省略（参考运算第7点）</p></li><li><code>@public</code> 和 <code>@private</code> 标记符应该以一个空格来进行缩进</li><li>建议加载<code>xib</code>，<code>xib</code>名称用<code>NSStringFromClass()</code>，避免书写错误</li><li>使用第三方框架，尽量不要更改内部文件，而应该再次封装，个性定制</li><li>删除所有无用代码（不用的代码直接删除，而不是注释掉）</li><li>空白行不要留空格（代码review是会显示成红色）</li></ol><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><ol><li>全部大写，单词间用 <code>_</code> 分隔 (<code>#define THIS_IS_AN_MACRO @&quot;THIS_IS_AN_MACRO&quot;</code>)</li><li>以字母 <code>k</code> 开头，后面遵循大驼峰命名 (<code>#define kWidth self.frame.size.width</code>)</li><li>不要使用 <code>#define</code> 宏来定义常量，因为如果使用宏定义, 一来宏可能被重定义. 二来引用不同的文件可能会导致宏的不同</li></ol><h3 id="运算相关"><a href="#运算相关" class="headerlink" title="运算相关"></a>运算相关</h3><ol><li>二元运算符和参数之间要有一个空格，如赋值号 <code>=</code> 左右各留一个空格</li><li>一元运算符和参数之间不放置空格，比如 <code>!</code>非运算符，<code>&amp;</code>按位与，<code>|</code>按位或</li><li>强制类型转换和参数之间不放置空格</li><li>浮点型变量不能用<code>==</code>或<code>！=</code>比较，无论是<code>float</code>类型还是<code>double</code>类型的变量，都有精度限制。<br> 所以一定要避免将浮点变量用<code>==</code>或<code>!=</code>与数字比较，应该转化成<code>&gt;=</code>或<code>&lt;=</code>形式</li><li><code>BOOL</code> 在 <code>Objective-C</code> 中被定义为 <code>signed char</code> 类型，这意味着一个 <code>BOOL</code> 类型的变量不仅仅可以表示 <code>YES(1)</code> 和 <code>NO(0)</code> 两个值，所以永远不要将 <code>BOOL</code> 类型变量直接和 <code>YES</code> 比较</li><li><p>判断<code>if</code>书写方式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">//建议这样写</span><br><span class="line">if (indexPath.row == 0) return 44;</span><br><span class="line">if (indexPath.row == 1) return 80;</span><br><span class="line">if (indexPath.row == 2) return 50;</span><br><span class="line">return 44;</span><br><span class="line"></span><br><span class="line">//而不是</span><br><span class="line">if (indexPath.row == 0) &#123;</span><br><span class="line">return 44;</span><br><span class="line">&#125; else if (indexPath.row == 1) &#123;</span><br><span class="line">        return 80;</span><br><span class="line">&#125; else if (indexPath.row == 2) &#123;</span><br><span class="line">        return 50;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">        return 44;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ol><li><p>用<code>@[]</code>构建<code>NSArray</code>，用<code>@{}</code>构建<code>NSDictionary</code><br> 如果构造代码写在一行，需要在括号两端留有一个空格，使得被构造的元素于与构造语法区分开来</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 正确，在语法糖的 &quot;[]&quot; 或者 &quot;&#123;&#125;&quot; 两端留有空格</span><br><span class="line">NSArray *array = @[ [foo description], @&quot;Another String&quot;, [bar description] ];</span><br><span class="line">NSDictionary *dict = @&#123; NSForegroundColorAttributeName : [NSColor redColor] &#125;;</span><br><span class="line"></span><br><span class="line">// 不正确，不留有空格降低了可读性</span><br><span class="line">NSArray* array = @[[foo description], [bar description]];</span><br><span class="line">NSDictionary* dict = @&#123;NSForegroundColorAttributeName: [NSColor redColor]&#125;;</span><br></pre></td></tr></table></figure><p> 如果构造代码不写在一行内，构造元素需要使用两个空格来进行缩进，右括号 <code>]</code> 或者 <code>}</code> 写在新的一行，并且与调用语法糖那行代码的第一个非空字符对齐。<br> 构造字典时，字典的 <code>Key</code> 和 <code>Value</code> 与中间的冒号 <code>:</code> 都要留有一个空格，多行书写时，也可以将 <code>Value</code> 对齐</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//正确，冒号&apos;:&apos;前后留有一个空格</span><br><span class="line">NSDictionary *option1 = @&#123;</span><br><span class="line">NSFontAttributeName : [NSFont fontWithName:@&quot;Helvetica-Bold&quot; size:12],</span><br><span class="line">NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//正确，按照Value来对齐</span><br><span class="line">NSDictionary *option2 = @&#123;</span><br><span class="line">NSFontAttributeName :            [NSFont fontWithName:@&quot;Arial&quot; size:12],</span><br><span class="line">NSForegroundColorAttributeName : fontColor</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用带有 <code>@</code> 符号的语法糖来生成<code>NSNumber</code> 对象能使代码更简洁：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSNumber *fortyTwo = @42;</span><br><span class="line">NSNumber *piOverTwo = @(M_PI / 2);</span><br><span class="line">enum &#123;</span><br><span class="line">kMyEnum = 2;</span><br><span class="line">&#125;;</span><br><span class="line">NSNumber *myEnum = @(kMyEnum);</span><br></pre></td></tr></table></figure></li></ol><h2 id="三-变量相关："><a href="#三-变量相关：" class="headerlink" title="三.变量相关："></a>三.变量相关：</h2><ol><li>类属性，临时变量采用小驼峰命名（<code>firstName</code>）；</li><li>指针<code>*</code>的位置，挨着变量名（<code>NSString *varName</code>）</li><li>局部变量不要与全局变量重名</li><li>成员变量使用<code>_</code>作为前缀，（<code>NSDictionary *_userInfo</code>）</li><li><p>使用 <code>const</code> 定义浮点型或者单个的整数型常量，如果要定义一组相关的整数常量，应该优先使用枚举</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const CGFloat kTableViewCellHeight = 50.0f;</span><br><span class="line">const NSInteger kTableViewRows = 5;</span><br></pre></td></tr></table></figure></li><li><p>对于拥有<code>Mutable</code>子类型的对象(e.g. <code>NSString</code>, <code>NSArray</code>, <code>NSDictionary</code>)一定要定义成<code>copy</code>属性</p></li><li>如果是内部使用的属性, 那么就定义成私有的属性(定义到<code>.m</code>的<code>class extension</code>里面)</li><li>尽量不要暴露<code>mutable</code>类型的对象在<code>public interface</code>, 建议在<code>.h</code>定义一个<code>Inmutable</code>类型的属性, 然后在<code>.m</code>的<code>get</code>函数里面返回一个内部定义的<code>mutable</code>变量</li><li>尽量不要使用死值，死值每次修改的时候容易被遗忘，地方多了找起来就悲剧了。而且定义成枚举或者<code>static</code>可以让错误发生在编译阶段。另外仅仅看到一个数字，完全不知道这个数字代表的意义</li><li><p>如果声明的属性，只想使用的<code>get</code>方法，不使用<code>set</code>方法，并且不想让外界更改这个属性的值，那么建议在括号里面加<code>readonly</code></p></li><li><p>给属性命名时建议采用修饰+类型的方式。以免产生歧义，比如<code>title</code> (这个到底是个<code>NSString</code>还是<code>UILabel</code>?)。同样的，<code>label</code> 我知道你是个<code>UILabel</code>，但是我不知道它是用来做什么的呀？）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//正确的命名方式为</span><br><span class="line">titleLabel    //表示标题的label,  是UILabel类型</span><br><span class="line">confirmButton //表示确认的button, 是UIButton类型</span><br></pre></td></tr></table></figure></li><li><p>一个类的 <code>Delegate</code> 对象通常还引用着类本身，这样很容易造成引用循环的问题，所以类的 <code>Delegate</code> 属性要设置为弱引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;XXXX&gt; delegate;</span><br></pre></td></tr></table></figure></li><li><p>如果属性是<code>BOOL</code>类型，建议在括号中重写<code>get</code>方法名称，以提高可读性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,readonly,getter=isKeyWindow) BOOL keyWindow;</span><br></pre></td></tr></table></figure></li></ol><h2 id="四-函数相关："><a href="#四-函数相关：" class="headerlink" title="四.函数相关："></a>四.函数相关：</h2><ol><li>不要使用 <code>new</code> 方法创建对象</li><li>在每个方法的定义前留白一行，也就是在方法和方法之间留空一行</li><li>避免函数有太多的参数，这样容易把参数顺序搞错，调用不方便，若较多，可把参数定义成一个结构体，把结构体的指针当成参数传入</li><li>参数过多时，每个参数占用一行，以冒号对齐</li><li>函数长度不要超过50行，小函数比大函数可读性更强。函数的参数不宜过多，零元函数最好，一元函数也不错，高于三元的函数需重构</li><li><code>{</code>可写在方法末尾（加空格），也可另起一行</li><li>私有方法在方法名前加<code>p_</code></li><li>使用 <code>#pragma mark -</code> 方式对类的方法进行分组</li><li><code>dealloc</code>函数放在最前面</li><li>保持公共<code>API</code>的简洁性</li><li>不要用点分语法来调用方法，只用来访问属性。这样是为了防止代码可读性问题</li><li>函数调用的格式和声明格式一样。</li><li><p>如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加<code>get</code>或者其他的动词前缀<br>为什么 <code>Objective-C</code> 中不适用 <code>get</code> 前缀来表示属性获取方法？因为 <code>get</code> 在 <code>Objective-C</code> 中通常只用来表示从函数指针返回值的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 三个参数都是作为函数的返回值来使用的，这样的函数名可以使用 &quot;get&quot; 前缀</span><br><span class="line">- (void)getLineDash:(float *)pattern count:(int *)count phase:(float *)phase;</span><br></pre></td></tr></table></figure></li><li><p>函数命名原则（遵循<code>Apple</code>风格）：小驼峰，尽量清晰明了，采用单词全拼，冒号对齐；尽量做到不需要注释也能了解其作用<br><code>-</code> 和 <code>(void)</code> 之间加空格，方法名和第一个参数之间不留空格，参数之前的关键字要明确(<code>middleName</code>,<code>lastName</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveMyFirstName:(NSString *)firstName</span><br><span class="line">             middleName:(NSString *)middleName</span><br><span class="line">               lastName:(NSString *)lastName;</span><br></pre></td></tr></table></figure></li><li><p>m文件函数实现：第一个大括号换行,其他使用场景(<code>if</code> <code>while</code> <code>else</code>)等左括号跟在第一行后面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveMyFirstName:(NSString *)firstName</span><br><span class="line">             middleName:(NSString *)middleName</span><br><span class="line">               lastName:(NSString *)lastName</span><br><span class="line">&#123;</span><br><span class="line">while (1) &#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">if (1) &#123;</span><br><span class="line"></span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>黄金路径，使用条件语句时，左手的代码应该是”golden” 或 “happy”路径。也就是不要嵌套<code>if</code>语句，多个返回语句也是OK。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//应该：</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">if (![someOther boolValue]) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//Do something important</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//不应该：</span><br><span class="line">- (void)someMethod &#123;</span><br><span class="line">if ([someOther boolValue]) &#123;</span><br><span class="line">//Do something important</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在继承中，凡是要求子类重写父类的方法必须先调用父类的这个方法进行初始化操作;<br>建议:父类的方法名后面加上 <code>NS_REQUIRES_SUPER</code> ; 子类重写这个方法就会自动警告提示要调用这个 <code>super</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注意:父类中的方法加`NS_REQUIRES_SUPER`,子类重写才有警告提示</span><br><span class="line">- (void)prepare NS_REQUIRES_SUPER;</span><br></pre></td></tr></table></figure></li></ol><h2 id="五-UI布局相关："><a href="#五-UI布局相关：" class="headerlink" title="五. UI布局相关："></a>五. UI布局相关：</h2><ol><li>尽量使用<code>Storyboard</code> + 自动布局</li><li>代码布局时尽量使用相对布局，比如使用子<code>View</code>在父<code>View</code>中的相对位置</li><li>与主题颜色相关的控件添加引用在代码中设置，方便同意替换主题色</li></ol><h2 id="六-类，协议相关："><a href="#六-类，协议相关：" class="headerlink" title="六. 类，协议相关："></a>六. 类，协议相关：</h2><ol><li>类采用前缀加大驼峰命名规则（<code>SSCPersonViewController</code>）;</li><li>协议加<code>delegate</code>或其他比较明确能看出是协议的后缀（<code>delegate</code>，<code>protocol</code>，<code>DataSource</code>等）</li><li>协议中的方法遵循<code>Apple</code>系统风格，参考（<code>UITableViewDelegate</code>，<code>UITableViewDataSource</code>的函数风格）</li><li>对外暴露的接口和属性放头文件，不暴露的放在<code>m</code>文件；</li><li>给分类扩充方法，建议加上前缀，同理跟分类添加属性（利用运行时），建议加前缀</li><li><p>一个委托方法的第一个参数是触发它的对象，第一个关键词是触发对象的类名，除非委托方法只有一个名为 <code>sender</code> 的参数：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 第一个关键词为触发委托的类名</span><br><span class="line">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;</span><br><span class="line">- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</span><br><span class="line"></span><br><span class="line">// 当只有一个 &quot;sender&quot; 参数时可以省略类名</span><br><span class="line">- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</span><br><span class="line"></span><br><span class="line">//根据委托方法触发的时机和目的，使用 should,will,did 等关键词</span><br><span class="line">- (void)browserDidScroll:(NSBrowser *)sender;</span><br><span class="line">- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window; 、</span><br><span class="line">- (BOOL)windowShouldClose:(id)sender;</span><br></pre></td></tr></table></figure></li><li><p>类型标识符、代理名称、尖括号间不留空格，该规则同样适用于<code>delegate</code>申明</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>如果类申明中包含多个    protocal    ，每个    protocal`占用一行，缩进 4 个字符</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface SSCOrderViewController ()&lt;</span><br><span class="line">UITableViewDelegate,</span><br><span class="line">UITableViewDataSource,</span><br><span class="line">SSCOrderEstimateCellDelegate</span><br><span class="line">&gt; &#123;</span><br><span class="line">…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="七-Block："><a href="#七-Block：" class="headerlink" title="七. Block："></a>七. Block：</h2><ol><li>注意必要时使用<code>WEAKSELF</code>和<code>STRONGSELF</code>，避免造成循环引用，以及野指针（常见于访问实例变量，<code>NSTimer</code>等场景）</li><li>较短的 <code>block</code> 可以写在一行内。</li><li>如果分行显示的话， <code>block</code> 的右括号 <code>}</code> 应该和调用 <code>block</code> 那行代码的第一个非空字符对齐。</li><li><code>block</code> 内的代码采用 4 个空格 的缩进。</li><li>如果 <code>block</code> 过于庞大，应该单独声明成一个变量来使用。</li><li><p><code>^</code> 和 <code>(</code> 之间， <code>^</code> 和 <code>{</code> 之间都没有空格，参数列表的右括号 <code>)</code> 和 <code>{</code> 之间有一个空格</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 较短的 block 写在一行内</span><br><span class="line">[operation setCompletionBlock:^&#123; [self onOperationDone]; &#125;];</span><br><span class="line"></span><br><span class="line">// 分行书写的 block ，内部使用 4 空格缩进</span><br><span class="line">[operation setCompletionBlock:^&#123;</span><br><span class="line">[self.delegate newDataAvailable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 使用 C 语言 API 调用的 block 遵循同样的书写规则</span><br><span class="line">dispatch_async(_fileIOQueue, ^&#123;</span><br><span class="line">NSString* path = [self sessionFilePath];</span><br><span class="line">if (path) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 较长的 block 关键字可以缩进后在新行书写，注意 block 的右括号 &apos;&#125;&apos; 和调用 block 那行代码的第一个非空字符对齐</span><br><span class="line">[[SessionService sharedService]</span><br><span class="line">loadWindowWithCompletionBlock:^(SessionWindow *window) &#123;</span><br><span class="line">if (window) &#123;</span><br><span class="line">[self windowDidLoad:window];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self errorLoadingWindow];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 较长的 block 参数列表同样可以缩进后在新行书写</span><br><span class="line">[[SessionService sharedService]</span><br><span class="line">loadWindowWithCompletionBlock:</span><br><span class="line">^(SessionWindow *window) &#123;</span><br><span class="line">if (window) &#123;</span><br><span class="line">[self windowDidLoad:window];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">[self errorLoadingWindow];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 庞大的 block 应该单独定义成变量使用</span><br><span class="line">void (^largeBlock)(void) = ^&#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;;</span><br><span class="line">[_operationQueue addOperationWithBlock:largeBlock];</span><br><span class="line"></span><br><span class="line">// 在一个调用中使用多个 block ，注意到他们不是像函数那样通过 &apos;:&apos; 对齐的，而是同时进行了 4 个空格的缩进</span><br><span class="line">[myObject doSomethingWith:arg1</span><br><span class="line">firstBlock:^(Foo *a) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;</span><br><span class="line">secondBlock:^(Bar *b) &#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li></ol><h2 id="八-单词简写"><a href="#八-单词简写" class="headerlink" title="八. 单词简写"></a>八. 单词简写</h2><p>不要使用单词的简写，拼写出完整的单词：  </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 清晰</span><br><span class="line">destinationSelection</span><br><span class="line">setBackgroundColor:</span><br><span class="line">// 不清晰，不要使用简写</span><br><span class="line">destSel</span><br><span class="line">setBkgdColor:</span><br></pre></td></tr></table></figure></code></pre><p>然而，有部分单词简写在 <code>Objective-C</code> 编码过程中是非常常用的，以至于成为了一种规范，这些简写可以在代码中直接使用  </p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">alloc == Allocate</span><br><span class="line">max == Maximum</span><br><span class="line">alt == Alternate</span><br><span class="line">min == Minimum</span><br><span class="line">app == Application</span><br><span class="line">msg == Message</span><br><span class="line">calc == Calculate</span><br><span class="line">nib == Interface Builder archive</span><br><span class="line">dealloc == Deallocate</span><br><span class="line">pboard == Pasteboard</span><br><span class="line">func == Function</span><br><span class="line">rect == Rectangle</span><br><span class="line">horiz == Horizontal</span><br><span class="line">Rep == Representation (used in class name such as NSBitmapImageRep).</span><br><span class="line">info == Information</span><br><span class="line">temp == Temporary</span><br><span class="line">init == Initialize</span><br><span class="line">vert == Vertical</span><br><span class="line">int == Integer</span><br><span class="line">btn == button</span><br><span class="line">txf == textField</span><br><span class="line">dict == dictionary</span><br></pre></td></tr></table></figure></code></pre><h2 id="九-注释"><a href="#九-注释" class="headerlink" title="九. 注释"></a>九. 注释</h2><ol><li>方法头部应进行注释，列出：函数的功能、输入参数、输出参数、返回值、修改信息等</li><li>全局变量要有详细的注释，包括对其功能、取值范围等说明</li><li>定义在头文件里的接口方法、属性必须要有注释</li><li><p>每个文件都必须写文件注释，文件注释通常包含：文件所在模块、作者信息、历史版本信息、版权信息、文件包含的内容，作用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">一段良好文件注释的栗子：</span><br><span class="line"></span><br><span class="line">/*******************************************************************************</span><br><span class="line">Copyright (C), 2011-2013, Andrew Min Chang</span><br><span class="line">File name: AMCCommonLib.h</span><br><span class="line">Author: Andrew Chang (Zhang Min)</span><br><span class="line">E-mail: LaplaceZhang@126.com</span><br><span class="line">Description:</span><br><span class="line">This file provide some covenient tool in calling library tools. One can easily include</span><br><span class="line">library headers he wants by declaring the corresponding macros.</span><br><span class="line">I hope this file is not only a header, but also a useful Linux library note.</span><br><span class="line">History:</span><br><span class="line">2012-??-??: On about come date around middle of Year 2012, file created as &quot;commonLib.h&quot;</span><br><span class="line">2012-08-20: Add shared memory library; add message queue.</span><br><span class="line">2012-08-21: Add socket library (local)</span><br><span class="line">2012-08-22: Add math library</span><br><span class="line">2012-08-23: Add socket library (internet)</span><br><span class="line">2012-08-24: Add daemon function</span><br><span class="line">2012-10-10: Change file name as &quot;AMCCommonLib.h&quot;</span><br><span class="line">2012-12-04: Add UDP support in AMC socket library</span><br><span class="line">2013-01-07: Add basic data type such as &quot;sint8_t&quot;</span><br><span class="line">2013-01-18: Add CFG_LIB_STR_NUM.</span><br><span class="line">2013-01-22: Add CFG_LIB_TIMER.</span><br><span class="line">2013-01-22: Remove CFG_LIB_DATA_TYPE because there is already AMCDataTypes.h</span><br><span class="line">Copyright information:</span><br><span class="line">This file was intended to be under GPL protocol. However, I may use this library</span><br><span class="line">in my work as I am an employee. And my company may require me to keep it secret.</span><br><span class="line">Therefore, this file is neither open source nor under GPL control.</span><br><span class="line">********************************************************************************/</span><br></pre></td></tr></table></figure></li><li><p>方法、函数、类、协议、类别的定义都需要注释，推荐采用Apple的标准注释风格，<br> 好处是可以在引用的地方<code>alt+点击</code>查看注释，非常方便</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">一些良好的注释：</span><br><span class="line"></span><br><span class="line">objective-c</span><br><span class="line">/**</span><br><span class="line"> *  Create a new preconnector to replace the old one with given mac address.</span><br><span class="line"> *  NOTICE: We DO NOT stop the old preconnector, so handle it by yourself.</span><br><span class="line"> *</span><br><span class="line"> *  @param type       Connect type the preconnector use.</span><br><span class="line"> *  @param macAddress Preconnector&apos;s mac address.</span><br><span class="line"> */</span><br><span class="line">- (void)refreshConnectorWithConnectType:(IPCConnectType)type  Mac:(NSString *)macAddress;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Stop current preconnecting when application is going to background.</span><br><span class="line"> */</span><br><span class="line">-(void)stopRunning;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  Get the COPY of cloud device with a given mac address.</span><br><span class="line"> *</span><br><span class="line"> *  @param macAddress Mac address of the device.</span><br><span class="line"> *</span><br><span class="line"> *  @return Instance of IPCCloudDevice.</span><br><span class="line"> */</span><br><span class="line">-(IPCCloudDevice *)getCloudDeviceWithMac:(NSString *)macAddress;</span><br><span class="line"></span><br><span class="line">// A delegate for NSApplication to handle notifications about app</span><br><span class="line">// launch and shutdown. Owned by the main app controller.</span><br><span class="line">@interface MyAppDelegate : NSObject &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>协议、委托的注释要明确说明其被触发的条件：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objective-c</span><br><span class="line">/** Delegate - Sent when failed to init connection, like p2p failed. */</span><br><span class="line">-(void)initConnectionDidFailed:(IPCConnectHandler *)handler;</span><br></pre></td></tr></table></figure></li><li><p>如果在注释中要引用参数名或者方法函数名，使用 <code>||</code> 将参数或者方法括起来以避免歧义：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objective-c</span><br><span class="line">// Sometimes we need |count| to be less than zero.</span><br><span class="line">// Remember to call |StringWithoutSpaces(&quot;foo bar baz&quot;)|</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Category的加载机制</title>
      <link href="/2017/07/07/Category%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/07/07/Category%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>一直在使用Category，但是对Category的机制不太了解，这里对Category的机制进行一个总结。</p><p>参考：<a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">传送门</a></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>Category是在程序启动时作用的， 并且是在 <code>+ load</code> 方法调用前</li><li>如果类和Category都有<code>+ load</code>方法，这个<code>+ load</code>的加载顺序是：先类，后Category</li><li>Category是运行时决议，Swift 的 Extension 是编译时决议</li><li>Category是 runtime 在程序启动时，进行作用<ul><li>加载实例方法到 <code>class</code> 的函数列表中</li><li>加载类方法到 <code>meta class</code> 的函数列表中</li></ul></li><li>Category增加方法，会更新 <code>class</code> 和 <code>meta class</code> 的函数列表，Category新增的方法在前， 原函数列表在后；</li><li>Category如果新增了一个同名的方法，其实并没有替换到原来的函数，只是新增的同名方法在函数列表的前面，原来的方法在后面，所以有时会给人一个错觉——覆盖了方法</li></ol>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Category </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>atomic是不是线程安全的？</title>
      <link href="/2017/05/27/atomic%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/"/>
      <url>/2017/05/27/atomic%E6%98%AF%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F/</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>记得以前面试的时候，有面试官问到atomic安全不安全，今天突然想起了这个问题，再总结记录一下。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>atomic是线程不安全的。</p><p>atomic只是保证了getter和setter存取方法的线程安全，但并不能保证这个属性所对应的成员变量是线程安全的。</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>意思就是： 如果多个线程调用了getter或者setter，那么这些getter和setter的调用时线性的， 保证了同一时间只有一个函数(setter和getter)在调用， 但是并不能避免这个属性所对应的成员变量是线程安全的。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (atomic) NSString * name;</span><br></pre></td></tr></table></figure><p>系统自动生成的getter: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(NSString *)name;</span><br></pre></td></tr></table></figure><p>Setter:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(void)setName:(NSString *)name;</span><br></pre></td></tr></table></figure><p>假设name所对应的成员变量是<code>_name</code>。</p><p>atomic保证的是，setter和getter是线程安全的。<br>如，线程1调用getter了，线程2调用了setter，线程3调用了setter，那么atomic保证了一个线程的调用顺序：getter-&gt;setter-&gt;setter.</p><p>但是atomic并不能保证成员变量_name的线程安全。例如上面的例子中， 如果有个线程4直接release了_name， 那么在线程1、线程2或者线程3的调用过程中， 直接造成崩溃。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>再总结一下NSString 与 NSMutableString 的 property 约束</title>
      <link href="/2017/04/02/%E5%86%8D%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8BNSString%20%E4%B8%8E%20NSMutableString%20%E7%9A%84%20property%20%E7%BA%A6%E6%9D%9F/"/>
      <url>/2017/04/02/%E5%86%8D%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8BNSString%20%E4%B8%8E%20NSMutableString%20%E7%9A%84%20property%20%E7%BA%A6%E6%9D%9F/</url>
      <content type="html"><![CDATA[<p>之前在网上看了很多关于 NSString 的 property 约束，不过总感觉总结得没那么直接。这里我再重复的总结一下。</p><h3 id="对于-NSString-来说，到底用-copy-还是-strong"><a href="#对于-NSString-来说，到底用-copy-还是-strong" class="headerlink" title="对于 NSString 来说，到底用 copy 还是 strong?"></a>对于 NSString 来说，到底用 copy 还是 strong?</h3><p>看看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface Test: NSObject</span><br><span class="line">@property (nonatomic, strong) NSString * string;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Some Code here …………</span><br><span class="line"></span><br><span class="line">NSMutableString * aStr = [@&quot;hello&quot; mutableCopy];</span><br><span class="line">Test * test = [Test new];</span><br><span class="line">test.string = aStr;</span><br><span class="line">[aStr appendString:@&quot; world&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, test.string);</span><br></pre></td></tr></table></figure><p>以上代码，原本打算 test 对象的 string 对象赋值之后就不会改变，即一直都是 hello，然而上面的代码输出是 hello world，违背了代码设计的初衷。</p><p>NSString 如果使用 strong 的话， 从外部给这个属性赋值，可能是一个 NSMutableString，如果外部把这个 NSMutableString 的值给改变了， 那么这个属性的值也会被改变。</p><h3 id="对于NSMutableString来说，用-copy-还是-strong"><a href="#对于NSMutableString来说，用-copy-还是-strong" class="headerlink" title="对于NSMutableString来说，用 copy 还是 strong?"></a>对于NSMutableString来说，用 copy 还是 strong?</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@interface Test: NSObject</span><br><span class="line">@property (nonatomic, copy) NSMutableString * mString;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Some Code here …………</span><br><span class="line"></span><br><span class="line">NSMutableString * aStr = [@&quot;hello&quot; mutableCopy];</span><br><span class="line">Test * test = [Test new];</span><br><span class="line">test.mString = aStr;</span><br><span class="line">[test.mString appendString:@&quot;world&quot;];</span><br></pre></td></tr></table></figure><p>以上代码中，test 对象的 mString 属性，由于定义的 copy，然而<code>copy属性会拷贝一个不可变的值</code>，然而我们对它进行一些可变协议的操作，即执行：[NSString appendString:]，程序崩溃。</p><p>NSMutableString 如果使用 copy 的话，将一个外部对象赋值给这个属性的时候， 会进行一次 copy 操作， 然而 copy 是拷贝出一个不可变的对象给属性（实际上应该调用 mutableCopy，但是@property 并没有 mutableCopy），如果之后对这个属性（实际上是一个不可变的对象）进行可变协议的调用， 那么程序就会崩溃。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>和 NSString 与 NSMutableString 类似，NSArray 与 NSMutableArray， NSDictionary 与 NSMutableDictiontary也与以上运行效果一致。</p><ul><li><strong>NSString, NSArray 与 NSDictionary 使用 copy；</strong></li><li><strong>NSMutableString, NSMutableArray 与 NSMutableDictionary使用 strong。</strong></li></ul>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> OC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化之离屏渲染</title>
      <link href="/2017/03/20/%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2017/03/20/%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      <content type="html"><![CDATA[<p>这篇文章主要是总结一下我对离屏渲染的理解，之前一直不太理解离屏渲染到底是个什么，也不太理解为什么他会引起滚动界面卡顿，一直也没有去深入了解，自己也深感惭愧。以前看到了<a href="https://blog.ibireme.com" target="_blank" rel="noopener">@ibireme</a>写的<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a>这篇文章，里面也描述了下屏幕显示原理。现在再次深入阅读，才比较理解离屏渲染到底是怎么回事。</p><h3 id="屏幕显示原理"><a href="#屏幕显示原理" class="headerlink" title="屏幕显示原理"></a>屏幕显示原理</h3><p>引用一下<a href="https://blog.ibireme.com" target="_blank" rel="noopener">@ibireme</a>的原文</p><blockquote><p>首先从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。</p></blockquote><blockquote><p>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</p></blockquote><figure class="image-box">                <img src="2017-03-20/ios_screen_scan.png" alt="" title="" class="">                <p></p>            </figure><blockquote><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p></blockquote><p>这里介绍了 GPU 为了效率问题，使用了两个帧缓冲区。对于帧缓冲区的个数，iOS 系统中使用的是双缓冲机制，而 Android 使用的三缓冲机制。题外话，不得不佩服 iOS 系统的设计，在硬件不如 Android 的提前下，界面的流畅度却超过 Android 机器。</p><h3 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h3><p>直接引用网络上的一段文字：</p><blockquote><p>OpenGL中，GPU屏幕渲染有以下两种方式：</p><ol><li><strong>On-Screen Rendering</strong> 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。</li><li><strong>Off-Screen Rendering</strong> 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</li></ol></blockquote><p>对于一个 UIView 的渲染过程：</p><blockquote><ol><li>UIView的layer层有一个content，指向一块缓存，即backing store</li><li>UIView绘制时，会调用drawRect方法，通过context将数据写入backing store</li><li>在backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上</li></ol></blockquote><figure class="image-box">                <img src="2017-03-20/uiview_render.png" alt="" title="" class="">                <p></p>            </figure><p>当我们在使用<strong>Group Opacity</strong>、<strong>corner（圆角）</strong>、<strong>shadow（阴影）</strong>、<strong>edge antialiasing（抗锯齿）</strong>和<strong>mask</strong>等视图功能的时候，由于图层不是那种简单的覆盖，而是需要额外计算图层的显示关系，由于当前已经是 GPU 渲染了，所以在 GPU 的当前屏幕缓冲区外，新建了一个缓冲区，在这个缓冲区中，去进行这些额外的渲染，这就是离屏渲染。</p><ol><li>创建离屏缓冲区是一个代价是很大的。</li><li>（假设我们的在界面中画了圆角），如果我们创建的圆角 N 个，那么在这个离屏缓冲区中，去处理这 N 个圆角的时候，会大量的切换上下文，然而，切换上下文也是一个代价非常大的操作。</li></ol><p>所以，当在开发过程中，<strong>如果离屏渲染没有处理好，对 App 的性能影响是非常大的</strong>， 后文会有相关的实例对比。</p><h3 id="离屏渲染的优化"><a href="#离屏渲染的优化" class="headerlink" title="离屏渲染的优化"></a>离屏渲染的优化</h3><ul><li>尽量使用当前屏幕渲染。由于离屏渲染、CPU渲染可能带来的性能问题，一般情况下，尽量使用当前屏幕渲染。</li><li>由于 GPU 的浮点运算能力比 CPU 强，虽然 CPU 渲染的效率不如 GPU，但有时使用 CPU 渲染的效率会比 GPU 离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。</li></ul><h4 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h4><p>一般情况，我们写圆角的时候，会这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">view.layer.cornerRadius = 10;</span><br><span class="line">view.layer.masksToBounds = YES;</span><br></pre></td></tr></table></figure><p>运行时，查看 Off-screen Rendered</p><figure class="image-box">                <img src="2017-03-20/corner_offscreen_rendered.jpg" alt="corner_offscreen_rendered" title="" class="">                <p>corner_offscreen_rendered</p>            </figure><p>我们可以看到按钮上的四个角被黄色覆盖，表明这四个角被离屏渲染了，这是因为 GPU 渲染的时候，发现这个按钮不是一个规整的图形，不能简单的采用(x, y, width, height)的规则进行渲染，对于上面的四个角，必须进行离屏渲染，新建一块缓冲区进行计算渲染，和下一层的 layer 进行合成处理，这样才能再界面上形成一个有弧度的视觉效果。</p><p>然而这里只有四个角所处的矩形范围进行了离屏渲染，是因为计算机里面的图形坐标都是以类似于(x, y, width, height)的规则来描述的，也就是说是一个矩形图形。然而这儿不是整个按钮而只是其他的四个角的区域的原因，是因为效率问题，GPU 确定除了四个角所在的矩形区域之外， 其他的区域都不需要合成处理，这样选择性的进行离屏渲染，能够获得更高的性能。</p><p>这里我们如何处理圆角带来的离屏渲染呢？答案是采用 Core Graphics 提供的函数，在 CPU 里面绘制圆角，这样相当于在 CPU 处理的时候就已经 GPU 离屏渲染做的事情给完成了。</p><p>使用下面提供的代码能够给 UIView 的子类添加圆角，能够避免离屏渲染。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 仅添加圆角</span><br><span class="line">[view addCorner:30];</span><br><span class="line">// 添加圆角和边框</span><br><span class="line">[view addCorner:30 borderWidth:0.5 borderColor:[UIColor redColor]];</span><br></pre></td></tr></table></figure><p>由于<code>addCorner:</code>和<code>addCorner:borderWidth:borderColor:</code>的代码较长，需要查看和下载的，<a href="https://snippets.cacher.io/snippet/6450c5ef0cf37484bb58" target="_blank" rel="noopener">请点击此处查看下载</a></p><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>对于 shadow 来说，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor redColor].CGColor;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(5, 5);</span><br><span class="line">view.layer.shadowOpacity = 1.0;</span><br></pre></td></tr></table></figure><p>查看 Off-screen Rendered</p><figure class="image-box">                <img src="2017-03-20/shadow_offscreen_rendered.jpg" alt="corner_offscreen_rendered" title="" class="">                <p>corner_offscreen_rendered</p>            </figure><p>可以看到，整个 view 的 frame，包括 frame 之外还有一点都进行了离屏渲染。</p><p>这儿有一个问题，如果有谁知道，请在评论区讲解一下。<strong>为什么是整个 view 都被离屏渲染了呢？</strong> 为了效率中间的区域可以不需要被离屏渲染，但是对于 shadow 却被离屏渲染了？</p><p>对于 shadow 的优化，直接在上面的代码后面添加一句就行了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">view.layer.shadowColor = [UIColor redColor].CGColor;</span><br><span class="line">view.layer.shadowOffset = CGSizeMake(5, 5);</span><br><span class="line">view.layer.shadowOpacity = 1.0;</span><br><span class="line">// 添加 shadowPath，能够解决离屏渲染</span><br><span class="line">view.layer.shadowPath = [UIBezierPath bezierPathWithRect:view.bounds].CGPath;</span><br></pre></td></tr></table></figure><h4 id="Mask"><a href="#Mask" class="headerlink" title="Mask"></a>Mask</h4><p>一般的 Mask 设置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIImageView * mask = [[UIImageView alloc] initWithFrame:view.bounds];</span><br><span class="line">mask.image = [UIImage imageNamed:@&quot;mask.png&quot;];</span><br><span class="line">view.maskView = mask;</span><br></pre></td></tr></table></figure><p>对于 Mask 的优化，其实并没有一个很好的方式来解决，目前的解决方案是：rasterize（光栅化），然而 rasterize（光栅化）也会造成离屏渲染，不过由于离屏渲染大部分时候会在大量出现的时候造成性能问题，所以在滚动页面进行 rasterize（光栅化）的时候，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用, 把GPU的操作转到CPU上了，生成位图缓存，各种阴影遮罩等效果也会保存到位图中并缓存起来，直接读取复用，从而减少渲染的频度。rasterize（光栅化）有一个不好的效果，会造成文字 label 视觉效果模糊。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS的单元测试</title>
      <link href="/2016/11/22/iOS%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2016/11/22/iOS%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><p>Specta + OCMock + Expecta + OHHTTPStubs + FBSnapshotTestCase + “Expecta+Snapshots” </p><p>Specta: BDD框架 <a href="https://github.com/specta/specta" target="_blank" rel="noopener">参考链接</a></p><p>Expecta: 断言框架 <a href="https://github.com/specta/expecta" target="_blank" rel="noopener">参考链接</a></p><p>OCMock: mock框架 <a href="http://ocmock.org" target="_blank" rel="noopener">参考链接</a></p><p>FBSnapshotTestCase: 截图测试框架 <a href="https://github.com/facebookarchive/ios-snapshot-test-case" target="_blank" rel="noopener">参考链接</a></p><p>Expecta+Snapshots: FBSnapshotTestCase的扩展， 支持Expecta <a href="https://github.com/dblock/ios-snapshot-test-case-expecta" target="_blank" rel="noopener">参考链接</a></p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单元测试 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift中的闭包定义</title>
      <link href="/2016/08/21/Swift%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%AE%9A%E4%B9%89/"/>
      <url>/2016/08/21/Swift%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E5%AE%9A%E4%B9%89/</url>
      <content type="html"><![CDATA[<h4 id="定义闭包变量"><a href="#定义闭包变量" class="headerlink" title="定义闭包变量"></a>定义闭包变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var closureName: (ParameterTypes) -&gt; (ReturnType)</span><br></pre></td></tr></table></figure><h4 id="定义可选闭包变量"><a href="#定义可选闭包变量" class="headerlink" title="定义可选闭包变量"></a>定义可选闭包变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var closureName: ((ParameterTypes) -&gt; (ReturnType))?</span><br></pre></td></tr></table></figure><h4 id="定义闭包别名"><a href="#定义闭包别名" class="headerlink" title="定义闭包别名"></a>定义闭包别名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typealias ClosureType = (ParameterTypes) -&gt; (ReturnType)</span><br></pre></td></tr></table></figure><h4 id="定义闭包常量"><a href="#定义闭包常量" class="headerlink" title="定义闭包常量"></a>定义闭包常量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let closureName: ClosureType = &#123; ... &#125;</span><br></pre></td></tr></table></figure><h4 id="在函数内部"><a href="#在函数内部" class="headerlink" title="在函数内部"></a>在函数内部</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">funcName(&#123;(ParameterTypes) -&gt; (ReturnType) in statements&#125;)</span><br></pre></td></tr></table></figure><h4 id="作为函数参数"><a href="#作为函数参数" class="headerlink" title="作为函数参数"></a>作为函数参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1: Int, item2: Int) -&gt; Bool in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure><h4 id="作为函数参数-隐式参数类型"><a href="#作为函数参数-隐式参数类型" class="headerlink" title="作为函数参数(隐式参数类型)"></a>作为函数参数(隐式参数类型)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1, item2) -&gt; Bool in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure><h4 id="作为函数参数-隐式参数类型、隐式返回类型"><a href="#作为函数参数-隐式参数类型、隐式返回类型" class="headerlink" title="作为函数参数(隐式参数类型、隐式返回类型)"></a>作为函数参数(隐式参数类型、隐式返回类型)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&#123; (item1, item2) in return item1 &lt; item2 &#125;)</span><br></pre></td></tr></table></figure><h4 id="作为函数最后的参数"><a href="#作为函数最后的参数" class="headerlink" title="作为函数最后的参数"></a>作为函数最后的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; (item1, item2) in return item1 &lt; item2 &#125;</span><br></pre></td></tr></table></figure><h4 id="作为函数最后的参数-使用简略参数命名方式"><a href="#作为函数最后的参数-使用简略参数命名方式" class="headerlink" title="作为函数最后的参数(使用简略参数命名方式)"></a>作为函数最后的参数(使用简略参数命名方式)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; return $0 &lt; $1 &#125;</span><br></pre></td></tr></table></figure><h4 id="作为函数最后的参数-隐式返回值"><a href="#作为函数最后的参数-隐式返回值" class="headerlink" title="作为函数最后的参数(隐式返回值)"></a>作为函数最后的参数(隐式返回值)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort &#123; $0 &lt; $1 &#125;</span><br></pre></td></tr></table></figure><h4 id="作为函数最后的参数-as-a-reference-to-an-existing-function"><a href="#作为函数最后的参数-as-a-reference-to-an-existing-function" class="headerlink" title="作为函数最后的参数(as a reference to an existing function)"></a>作为函数最后的参数(as a reference to an existing function)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.sort(&lt;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift中的init</title>
      <link href="/2016/07/07/Swift%E4%B8%AD%E7%9A%84init/"/>
      <url>/2016/07/07/Swift%E4%B8%AD%E7%9A%84init/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近总算开始做新项目， 语言肯定的选Swift了。问题一个接一个，不过还好，来一个解决一个。<br>今天遇到了Swift中的init的问题， 用Xcode也没有自动补全，也没有看到相关init的东西，所以对init构造过程进行一个分析。</p><h3 id="两个类"><a href="#两个类" class="headerlink" title="两个类"></a>两个类</h3><p>有一个Parent的Class</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Parent: NSObject &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">NSLog(&quot;Parent Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个Child的Class继承于Parent</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Child: Parent &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">NSLog(&quot;Child Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用代码"><a href="#调用代码" class="headerlink" title="调用代码"></a>调用代码</h3><p>在其他的某个类中，初始化一个Child对象出来，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func doSomething() &#123;</span><br><span class="line">Child()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于Xcode没有默认添加super.init()，所以这里到底是怎样一个逻辑过程？<br>按照我对其他语言的理解，我猜测是有两种可能情况：</p><ol><li>只会输出Child Init</li><li>先输出Parent Init，然后输出Child Init”</li></ol><h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><p>代码的运行情况出乎我的意料</p><p>输出结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Child Init</span><br><span class="line">Parent Init</span><br></pre></td></tr></table></figure><p>居然先输出Child Init。</p><p>也就是说先调用了子类的init(), 然后再调用父类的init()。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Swift中的init过程，子类如果没有调用super.init()，那么会在子类的init()的<strong>末尾</strong>隐式添加super.init()</p><h3 id="我们该如何处理？"><a href="#我们该如何处理？" class="headerlink" title="我们该如何处理？"></a>我们该如何处理？</h3><p>一般情况，我们需要在子类的init()中，应该显式地、尽快地调用super.init()</p><p>如上面的Child类就该写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Child: Parent &#123;</span><br><span class="line">override init() &#123;</span><br><span class="line">super.init() // 显式的添加super.init()到第一行</span><br><span class="line">NSLog(&quot;Child Init&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift中iOS应用程序的MVVM模式</title>
      <link href="/2016/06/18/MVVM%E6%A8%A1%E5%BC%8F/"/>
      <url>/2016/06/18/MVVM%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h3 id="Swift中iOS应用程序的MVVM模式：一个实用的方法"><a href="#Swift中iOS应用程序的MVVM模式：一个实用的方法" class="headerlink" title="Swift中iOS应用程序的MVVM模式：一个实用的方法"></a><code>Swift</code>中<code>iOS</code>应用程序的<code>MVVM</code>模式：一个实用的方法</h3><figure class="image-box">                <img src="image/The-MVVM-Pattern-for-iOS-Apps-in-Swift-a-Pragmatic-Approach.png" alt="" title="" class="">                <p></p>            </figure><p><code>MVVM</code>最近在<code>iOS</code>开发社区中变得很流行。</p><p>但它并非没有争议，</p><p>我就是其中一个，我对<code>MVVM</code>的一些实现持保留意见，但我也认为它的一些想法是合理的。</p><p>在谈到缺点时，我不仅仅站在理论的角度，</p><p>我在真实的项目中也体验过它们。</p><p>我参与了一些跟随其中一些想法的项目，其中一个项目来自一家知名公司，结果该项目相对于计划延迟了几年发布。</p><p>几年时间，</p><p>你想想看。</p><p>虽然我不能说只有这一个原因，但所有这些原因中肯定包含对<code>MVVM</code>的实践。</p><p>在本文中，我们将看到：</p><ul><li><code>MVVM</code>和<code>MVC</code>之间的关系</li><li><code>MVVM</code>的详细信息</li><li><code>MVVM</code>模式中，网络请求代码应该放在哪里</li><li><code>MVVM</code>和实用的响应式编程框架，如<code>RxSwift</code></li><li>不同方法的优缺点</li><li>一个避免了许多问题的实用的方法，并包含具体的例子</li></ul><h3 id="在MVC模式中，View不应该知道相关App中Model的任何信息"><a href="#在MVC模式中，View不应该知道相关App中Model的任何信息" class="headerlink" title="在MVC模式中，View不应该知道相关App中Model的任何信息"></a>在<code>MVC</code>模式中，<code>View</code>不应该知道相关App中<code>Model</code>的任何信息</h3><p>让我们从我们试图解决的实际问题开始。</p><p>我在<code>iOS</code>应用中看到的最常见的<code>MVC</code>模式违规之一发生在<code>View</code>与应用的<code>Model</code>类型相关联时。</p><p>像任何重大错误一样，我过去也犯过这个错误，所以我很清楚它的样子。</p><p><a href="http://matteomanferdini.com/the-concepts-at-the-foundation-of-any-ios-app/" target="_blank" rel="noopener">我在文章中经常指出<code>MVC</code>模式的各个层</a>，我可以将<code>iOS</code>应用中的大部分问题都联系到违反这些原则的行为。</p><p>作为回顾，<code>iOS MVC</code>模式将我们的类型划分为4个（而不仅仅是3个）层：</p><ul><li><code>Model</code>类型代表数据以及业务逻辑</li><li><code>Model Controller</code>是与设备的接口，并以特定于应用的方式处理<code>Model</code>类型。例如保存App的状态，<br>  保存数据到磁盘或访问网络</li><li><code>View</code>在屏幕上展示信息并允许用户交互</li><li><code>View Controller</code>是<code>View</code>和<code>MVC</code>模式中较低层之间的桥梁。它将用于显示的数据传送给<code>View</code>，<br>  并解释用户的交互，指定应用程序屏幕的流程</li></ul><figure class="image-box">                <img src="image/The-basic-structure-of-the-MVC-pattern-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p><a href="https://matteomanferdini.com/understanding-the-core-architectural-principles-of-ios-development-with-a-practical-example/" target="_blank" rel="noopener">我已经写了很多关于这个的文章</a></p><p>正如我们在上面的观点中看到的，<code>View</code>需要从<code>View Controller</code>接收数据用于显示，它不直接访问<code>Model</code>。</p><h3 id="Model类型和View之间的桥接有其自身的问题"><a href="#Model类型和View之间的桥接有其自身的问题" class="headerlink" title="Model类型和View之间的桥接有其自身的问题"></a><code>Model</code>类型和<code>View</code>之间的桥接有其自身的问题</h3><p>将数据传递给<code>View Controller</code>中的<code>View</code>的问题来自以下事实，因为那样做会很容易：</p><ul><li>将<code>Model</code>类型直接传递给<code>View</code>以在屏幕上渲染</li><li>让<code>View Controller</code>对<code>View</code>的内部实现了解太多</li></ul><p>开发者经常做任何一个（或都做），因为它们是快速的解决方案。</p><p>但是两者都会引发问题，因为它们导致模块之间的耦合。第一个导致<code>Model</code>类型和<code>View</code>之间的耦合，<br>第二个在<code>View Controller</code>和<code>View</code>之间。</p><p>耦合使我们的模块更难以重用并且更容易破坏。</p><p>让我们更详细地看看这两个问题，</p><p>开发者经常将<code>Model</code>类型直接传递给<code>View</code>，以便<code>View</code>可以自己读取这些数据的格式。<br>但是如果你看看<code>MVC</code>中的角色，格式化数据并不是<code>View</code>的责任</p><p>这会在<code>View</code>和<code>Model</code>类型之间创建耦合，这意味着：</p><ul><li><code>View</code>很难在不同的屏幕之间以及不同的应用之间复用，如果要使用相同的<code>View</code>来展示另一个数据类型，事情就变得复杂了。<br>  这个视图需要知道两种不同的类型，并且能够区分它们。如果你想要在其他项目中重用这个<code>View</code>，则需要携带所有这些依赖项。</li></ul><ul><li><code>View</code>的实现捆绑到<code>Model</code>的实现，这意味着<code>Model</code>的任何改变都可能会破坏<code>View</code>的代码，然后需要重写代码。<br>  这可能不是那么简单，特别是如果<code>View</code>依赖于多个<code>Model</code>类型。</li></ul><p><code>MVC</code>模式使<code>View</code>独立于<code>Model</code>类型来解决这个问题，在<code>iOS</code>版<code>MVC</code>方案中，<code>View</code>和<code>Model</code>之间没有箭头。</p><p>这意味着<strong><code>View</code>仅获取简单格式的数据</strong></p><p>事实上，如果你查看<code>UIKit</code>框架的所有<code>UIView</code>，它们就会以这种方式工作。<code>Label</code>只需要一个简单的<code>String</code>来展示，  <code>Switch</code>、<code>Slider</code>、<code>ProgressView</code>只需要简单的类型，如<code>Bool</code>、<code>Int</code>、<code>Float</code>。</p><p>像<code>UITableView</code>这样复杂的视图会附加到<code>DataSource</code>。<br>为此，它让<code>Cell</code>来显示，请注意，<code>UITableView</code>不会要求数据，它只要求已经填充的<code>Cell</code>。</p><p>通过这种方式，<code>UITableView</code>可以保持通用，你可以将之用于应用中的任何<code>Model</code>类型。</p><h3 id="View不应该暴露其内部实现"><a href="#View不应该暴露其内部实现" class="headerlink" title="View不应该暴露其内部实现"></a><code>View</code>不应该暴露其内部实现</h3><p>当<code>View Controller</code>或其它对象对<code>View</code>的内部实现了解太多时，会发生对<code>MVC</code>模式的另一种违反。</p><p>你可以在<code>UITableView</code>的<code>DataSource</code>中经常看到这一点。</p><p><code>DataSource</code>需要在将<code>Cell</code>返回给<code>UITableView</code>之前用数据填充<code>Cell</code>。</p><p>一个常见的错误是让<code>DataSource</code>访问<code>Cell</code>的子视图来填充数据，</p><p>因此，<code>DataSource</code>经常访问<code>Cell</code>的<code>UILabel</code>、<code>UIImageView</code>和其它子视图以给它们赋值。<br>这可以通过<code>UIOutlet</code>发生，或者更糟糕的是，使用<code>UIview.viewWithTag()</code>方法，</p><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/TableView_iPhone/TableViewCells/TableViewCells.html#//apple_ref/doc/uid/TP40007451-CH7-SW18" target="_blank" rel="noopener">你甚至可以在苹果的官方文档中找到它们</a></p><p>这里的问题是这又引入了耦合，当我们更改<code>Cell</code>的实现时，我们会破坏访问它的所有<code>DataSource</code>。</p><p><code>UILabel</code>和其它子视图是<code>View</code>内部实现的一部分，任何对象都不应该依赖于另一个对象的内部实现。</p><p>事实上，<code>UIOutlet</code>甚至不应该暴露出来，我明确地将我代码中的<code>UIOutlet</code>都标记为<code>private</code>，<br><strong><code>UIOutlet</code>的所有者是唯一访可以问它的人</strong>。</p><p>这里的解决方案和上面的一样，<code>Cell</code>是一个<code>View</code>，和其它的<code>View</code>一样，因此，<a href="https://matteomanferdini.com/the-correct-way-to-display-lists-in-ios-and-what-many-developers-do-wrong/" target="_blank" rel="noopener">它只接受一种简单的数据格式</a>。<br>然后，自己有填充内部<code>UIOutlet</code>的责任。</p><h3 id="在View-Controller中做数据转换不是最优的"><a href="#在View-Controller中做数据转换不是最优的" class="headerlink" title="在View Controller中做数据转换不是最优的"></a>在<code>View Controller</code>中做数据转换不是最优的</h3><p>所以关于<code>View</code>的指导方针是：</p><ul><li>不要传递任何<code>Model</code>类型给它们</li><li>不要访问它们的内部实现</li></ul><p>正如我们所看到的，两者的解决方式是相同的：<strong><code>View</code>应该接受简单类型的数据</strong>。</p><p>因此，我们需要将<code>Model</code>类型的数据转换为简单类型，</p><p>这个转换过程通常在哪里完成？</p><p>确切地说：在<code>View Controller</code>内部。</p><p>诱惑有时候是把它放到<code>Model</code>类型中，但是<code>Model</code>类型不应该知道如何向用户呈现数据。</p><p>同样的数据在应用程序不同的部分可以有不同的呈现方式，这样就赋予<code>Model</code>类型太多职责而违反了<code>MVC</code>模式。</p><p><code>Model Controller</code>也不是正确的位置，它们只处理数据但并不关心他们怎么呈现。</p><p>现在就剩下<code>View Controller</code>了，但这同样也有问题。</p><p>要清楚，这并不是错误的。如果你遵循上面的<code>View</code>准则并将<code>MVC</code>定义的职责分开，那么你已经比很多复制-粘贴开发人员更胜一筹。</p><p>但是在<code>View Controller</code>中放置数据转换并不是最佳选择：</p><ul><li><p>首先，我们知道在<code>View Controller</code>中的代码往往会增长很多，<a href="https://matteomanferdini.com/how-to-structure-the-code-of-ios-apps/" target="_blank" rel="noopener">因为它在<code>iOS</code>中起着核心的作用</a>，<br>  因此，在可能的情况下，最好避免对这个问题作出贡献</p></li><li><p>这同样也影响代码重用，如果我们想在另一个界面使用相同的<code>View</code>，我们需要找到一种在<code>View Controller</code><br>  之间共享转换代码的方式</p></li></ul><p>也有一些这方面的解决方案。</p><p>例如，我们可以使用<code>Swift Extension</code>对相关的转换代码进行分组，这是一种有效的方法。</p><p>另一种方法是遵循<code>MVVM</code>模式。</p><h3 id="MVVM模式是MVC模式的扩展"><a href="#MVVM模式是MVC模式的扩展" class="headerlink" title="MVVM模式是MVC模式的扩展"></a><code>MVVM</code>模式是<code>MVC</code>模式的扩展</h3><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM模式</a>由微软公司开发。</p><p>是的，我知道，这很震惊。</p><p><code>MVVM</code>模式源于<code>MVC</code>模式，它旨在解决在<code>View Controller</code>内部发生模型对象转换的问题。</p><p><code>MVVM</code>的想法很简单。</p><p><strong>我们在<code>MVC</code>模式中的<code>View</code>和<code>View Controller</code>之间引入一个新层</strong>，负责处理数据转换。</p><figure class="image-box">                <img src="image/The-basic-structure-of-the-MVVM-pattern-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p>（是的，我知道这个图解不准确，请继续阅读。）</p><p>听起来相当简单，不是吗？</p><p>不幸的是，在<code>iOS</code>中，<code>MVVM</code>模式有其自身的问题。</p><p>像上面这样的图的缺点是它没有显示这些层之间的相互作用的所有细微差别，</p><p>这留下太多需要自我理解的东西。</p><p>如果你阅读关于<code>MVVM</code>的<code>iOS</code>开发文章，你会发现围绕它的不同想法，甚至<code>MVVM</code>呼声最高的支持者也不同意其中的一些观点。</p><p><a href="http://khanlou.com/2015/12/mvvm-is-not-very-good/" target="_blank" rel="noopener">本文对<code>MVVM</code>的分歧有很好的总结</a>，</p><p>这是让我长时间对<code>MVVM</code>持怀疑态度的原因之一，直到我找到了更实用的方法。</p><p>让我们看看这些问题。</p><h3 id="View-Model应该是值类型，而不是引用类型"><a href="#View-Model应该是值类型，而不是引用类型" class="headerlink" title="View Model应该是值类型，而不是引用类型"></a><code>View Model</code>应该是值类型，而不是引用类型</h3><p>我在<code>MVVM</code>中发现的第一个重大问题是将<code>View Model</code>作为引用类型。</p><p>这可能看起来像一个小细节，但是它有很大的影响。</p><p>在这个话题上，我和Andy Matuschack站在同一阵营。他非常好的讨论了我真正推荐的<a href="https://academy.realm.io/posts/andy-matuschak-controlling-complexity/" target="_blank" rel="noopener">引用类型和值类型之间的区别</a>。</p><p>这个观点是：</p><ul><li>值类型是惰性的，只能有一个所有者，这使得更容易推断它们的代码</li><li>引用类型可以拥有许多所有者，它们接受来至其它对象的方法调用，全局通知，回调，<code>KVO</code>通知等，这使得很难推断其代码</li></ul><p>这显示了<code>View Model</code>作为参考类型如何产生巨大差异。<code>View Model</code>成为有状态对象，可以通过代码的不同部分进行更新，<br>这通常会导致意外行为和奇怪的Workaround。</p><p>突然之间，你在<code>MVC</code>中有第三层，它本身就是行为。</p><p>您可以在<a href="https://www.objc.io/issues/13-architecture/mvvm/" target="_blank" rel="noopener"><code>iOS</code>的<code>MVVM</code>的大多数图解</a>中清楚地看到这一点，这通常采用以下形式：</p><figure class="image-box">                <img src="image/A-wrong-diagram-for-MVVM-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p>我只是为了向您展示相关信息，但我建议不要采用这种方法。</p><p>在这里你可以清楚地看到：</p><ul><li><code>View Model</code>是一个行为层。它<strong>拥有</strong><code>Model</code>并通过某种形式的通知或回调进行更新</li><li>甚至<code>Model</code>类型也是引用类型，这是它们能够向<code>View Model</code>发送信号的唯一方式</li><li>它似乎完全忽略了<code>MVC</code>的<code>Model Controller</code>层，实际上，<code>View Model</code>似乎取代了该方案中的<code>Model Controller</code></li></ul><p>行为<code>View Model</code>有很大的缺点。首先，你可以看到，在没有更多职责的情况下，它们至少有两个职责，<br>它们在将数据传递给<code>View</code>之前检索数据并对其进行格式化。</p><p>实际上，Andy Matuschak本人在他关于<a href="https://academy.realm.io/posts/andy-matuschak-refactor-mega-controller/" target="_blank" rel="noopener">重构<code>Mega Controller</code>的一次谈话中</a>发表了这番话。<br>在45:08时，他解释了<code>MVVM</code>中数据转换部分是正确的，但其余的都是错误的。</p><p>观看整个演讲，最大程度地影响了我写<code>iOS</code>应用程序方式。</p><p>因此，<code>View Model</code>作为参考类型天生存在问题。</p><p>但这只是冰山一角。</p><h3 id="网络代码不应该进入View-Model"><a href="#网络代码不应该进入View-Model" class="headerlink" title="网络代码不应该进入View Model"></a>网络代码不应该进入<code>View Model</code></h3><p><code>View Model</code>的另一个问题是，这个版本的<code>MVVM</code>的一些支持者认为，<a href="http://artsy.github.io/blog/2015/09/24/mvvm-in-swift/" target="_blank" rel="noopener">网络代码应该放在<code>View Model</code>中</a>。</p><p>在这里，我们看到将<code>View Model</code>作为引用类型的一个重要影响。如果它们是值类型，则这是不可能的。</p><p>在您的<code>MVVM</code>版本中，网络代码放在<code>View Model</code>中是可以理解的：</p><ul><li>没有考虑<code>Model Controller</code>的存在</li><li>明确声明<code>View Model</code>的行为以及通过回调或某种形式的通知来更新<code>View Controller</code></li></ul><p>这使得<code>View Controller</code>和<code>View Model</code>成为网络代码的唯一候选者。</p><p>由于每个人都知道<code>View Controller</code>已经太大了，因此网络代码自然而然的放在了<code>View Model</code>中。</p><p>这会在难以理解的对象之间创建一个非常复杂的回调网络，并导致许多错误。</p><p>我们甚至没有考虑单元测试，这会造成更多问题。</p><p>我已经证明<a href="http://matteomanferdini.com/network-requests-rest-apis-ios-swift/" target="_blank" rel="noopener">网络代码应该转移到<code>Model Controller</code>内部</a>，并且<code>Model type</code>应该是惰性值类型。</p><p>我们是否解决了这些问题？</p><p>还没有。</p><p>此版本的<code>MVVM</code>鼓励另一种模式，这对我来说像是<code>iOS</code>中的异步代码的灾难之源：<code>函数响应式编程</code>。</p><h3 id="函数响应式编程框架隐藏了幕后的大量复杂性"><a href="#函数响应式编程框架隐藏了幕后的大量复杂性" class="headerlink" title="函数响应式编程框架隐藏了幕后的大量复杂性"></a><code>函数响应式编程</code>框架隐藏了幕后的大量复杂性</h3><p>与此版本的<code>MVVM</code>经常相关的一件事是<code>函数响应式编程</code>（<code>FRP</code>）。</p><p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>是异步数据流的编程范例，它使用函数式编程的构建块，如map，reduce和filter。</p><p>在<code>iOS</code>中，<code>FRP</code>通常有不同的风格：</p><ul><li><code>RxSwift</code></li><li><code>ReactiveSwift</code>  和  <code>ReactiveCocoa</code></li></ul><p>使用<code>FRP</code>框架时，您的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let searchResults = searchBar.rx.text.orEmpty</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in</span><br><span class="line">        if query.isEmpty &#123;</span><br><span class="line">            return .just([])</span><br><span class="line">        &#125;</span><br><span class="line">        return searchGitHub(query)</span><br><span class="line">            .catchErrorJustReturn([])</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line"> </span><br><span class="line">searchResults</span><br><span class="line">    .bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">        (index, repository: Repository, cell) in</span><br><span class="line">        cell.textLabel?.text = repository.name</span><br><span class="line">        cell.detailTextLabel?.text = repository.url</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>我最初写了这段代码的详细分析，然后意识到这是浪费你我的时间。</p><p>我只想写几个注意事项，</p><p>这段代码隐藏了很多幕后的复杂性，即使在不需要异步代码的地方，也有很多异步操作和回调在后台进行。</p><p>实际上，您可以在<code>RxSwift</code>的文档页面中清楚地看到它，<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Why.md" target="_blank" rel="noopener">它涉及<code>binding</code>, <code>retrie</code>, <code>delegate</code>, <code>KVO</code>, <code>Notification</code></a>等。</p><p><code>FRP</code>背后的想法是你编写“声明性”代码并放弃对异步操作的控制。这正是我对<code>FRP</code>不喜欢的，它的代码不够明确。</p><p><code>FRP</code>粉丝通常回答：“但看看我写的代码有多少，它就像魔法一样！“</p><p>对我来说，这正是问题所在。</p><p>在软件开发中，<strong>如果某些东西看起来太聪明或看起来像魔术，那可能是个坏主意</strong></p><p>这种方法使编写代码变得非常容易，但：</p><blockquote><p>Programs must be written for people to read, and only incidentally for machines to execute.<br>程序必须写得能供人阅读，机器执行只是附带  </p><ul><li>Harold Abelson</li></ul></blockquote><p>这是一个定义问题，<code>FRP</code>的支持者会告诉你，这段代码正是如此：完全可读。</p><p>对我而言，事实并非如此。它达到如此高的抽象水平，很难知道它究竟做了什么。</p><p>此外，尝试在几个月内调试问题，此时您将无法了解所有这些异步代码的工作原理。正如Brian Kernighan曾经说过：</p><blockquote><p>每个人都知道调试的难度是最初编写程序的两倍。因为，如果您在编写时足够聪明，那么您现在怎么会调试它？</p></blockquote><p>这一点与上面讨论的相同。这会创建一个复杂的对象网络，它们以自己的方式运行，这使得很难推断出这段代码。</p><p>当然，你可以写得很快。但代码是写一次而读很多次。你将为节省时间付出代价。</p><p>最后，团队中的每个人都需要学习一个全新的范例。这段代码肯定很短，但<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="noopener"><code>RxSwift</code>的文档肯定不短</a>。</p><p>最后一个问题是<code>FRP</code>是一个范例，它的实现是不同的。</p><p><a href="https://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons" target="_blank" rel="noopener">在Stack Overflow上查看关于<code>RxSwift</code>和<code>ReactiveCocoa</code></a>的关于这个问题的答案。它在一开始就说：“比较两个世界是非常困难的”。<br>后来，结论是：“<code>RAC</code>和<code>RxSwift</code>是两个完全不同的野兽”。</p><p>所以这些范例不可互换。即使您了解一个<code>FRP</code>框架，当您使用另一个框架时，您可能还需要重新学习所有内容。</p><p>最后，选择权归你所有。在我看来，它产生的问题多于解决的问题。</p><p>如果你喜欢这种魔法编程，那就去吧。但是你可能就不喜欢我在材料中写的大部分内容。</p><p>相反，如果您想要遵循不同的<code>MVC</code>和<code>MVVM</code>方法，请继续阅读。</p><h3 id="View-Model作为惰性值类型"><a href="#View-Model作为惰性值类型" class="headerlink" title="View Model作为惰性值类型"></a><code>View Model</code>作为惰性值类型</h3><p>如果我们修改我们的<code>View Model</code>为值类型，我上面说明的所有内容都不再可能。</p><p>在<code>View Model</code>中不再有状态，网络和<code>FRP</code>，</p><p>这很好。</p><p>这种<code>MVVM</code>模式的<code>View Model</code>层变得惰性。因此，它不能是<code>View Controller</code>和<code>Model</code>之间的连接层。</p><p><code>View Model</code>变成了一个帮助层，它位于<code>View Controller</code>和<code>View</code>旁边，而不是它们之间。</p><p><code>View Model</code>的唯一责任就是以正确的格式将数据传递给<code>View</code>。我们所知道的<code>MVC</code>的各层之间的连接受到尊重：</p><figure class="image-box">                <img src="image/A-pragmatic-approach-to-MVVM-in-iOS.png" alt="" title="" class="">                <p></p>            </figure><p>您可以看到<code>View Model</code>中没有箭头。这是因为，正如名称所述，它们是模型对象。模型实体是惰性值类型。</p><p>但与我们的应用程序的模型类型（代表数据和业务逻辑）不同，<code>View Model</code>代表可视信息。</p><p>这允许我们：</p><ul><li>从<code>View Controller</code>中接管数据格式化的责任</li><li>定义简单视图类型以将数据传递给<code>View</code></li><li>使转换代码和自定义视图可以在我们的应用程序甚至跨不同项目中重复使用</li><li>扩展视图模型，以便相同的自定义视图可以显示不同类型的数据</li></ul><p>像往常一样，让我们​​看看所有这些理论的实际应用。</p><p>我们将构建一个显示航班信息的简单应用程序。</p><p>这将允许我显示模型类型，视图模型和转换代码之间的明确分离。</p><figure class="image-box">                <img src="image/Design-of-the-MVVM-example-app.png" alt="" title="" class="">                <p></p>            </figure><h3 id="MVVM的基本块是自定义视图"><a href="#MVVM的基本块是自定义视图" class="headerlink" title="MVVM的基本块是自定义视图"></a><code>MVVM</code>的基本块是自定义视图</h3><p>让我们从简单的东西开始吧。</p><p>首先，我们在<code>interface builder</code>中为<code>View Controller</code>创建界面。</p><figure class="image-box">                <img src="image/UI-for-the-MVVM-example-app-in-Interface-Builder-1024x650.png" alt="" title="" class="">                <p></p>            </figure><p>在这里，我使用简单<code>UIView</code>和<code>UILabel</code>的组合创建了遵循上述设计的卡片。</p><p>我使用<code>UIStackView</code>和<code>Auto Layout constraint</code>的组合放置了这些视图。我还为卡片周围的阴影设置了一些<br>用户定义的运行时属性。您可以在图像右侧看到这些值。</p><p>但这不是重要的事情。</p><p>由于这不是关于<code>Auto Layout</code>和<code>UI</code>的文章，我不会详细介绍。你可以<a href="https://github.com/matteom/FlightInfo" target="_blank" rel="noopener">在Github上找到他们的Xcode项目</a>，<br>并<a href="https://matteomanferdini.com/understanding-the-core-architectural-principles-of-ios-development-with-a-practical-example/" target="_blank" rel="noopener">在这篇文章中较长的讨论</a>，或在<a href="http://matteomanferdini.com/ultimate-course-making-professional-ios-apps/" target="_blank" rel="noopener">我的专业制作iOS应用免费课程</a>。</p><p>重要的是，根据我们的<code>MVVM</code>版本，这个<code>View</code>需要有一个自定义类，它隐藏了它的内部实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FlightCardView: UIView &#123;</span><br><span class="line">@IBOutlet private weak var airportSymbolsLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureAirportLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var airlineLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var flightNumberLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var durationLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalAirportLabel: UILabel!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，<code>FlightCardView</code>引用它自己的子视图，在这个例子中都是<code>UILabel</code>，通过<code>UIOutlet</code>连接。</p><p>通常看到<code>UIOutlet</code>仅从<code>View Controller</code>到其<code>View</code>中的所有界面元素。但是<code>View</code>也可以拥有到其子视图的<code>UIOutlet</code>。</p><p>这是<code>MVVM</code>的基本组成部分。</p><p>当<code>View Controller</code>具有到所有在其<code>View</code>中的接口元素的<code>UIOutlet</code>时，这意味着它对该<code>View</code>的内部实现了解太多。<br>所以它违反了我们上面列出的指导方针。</p><p>相反，使用自定义视图，<code>View Controller</code>不需要很多<code>UIOutlet</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class FlightInfoViewController: UIViewController &#123;</span><br><span class="line">@IBOutlet private weak var cardView: FlightCardView!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此示例中，我们的<code>View Controller</code>实际上只有一个<code>UIOutlet</code>。</p><h3 id="View不需要关心Model类型的结构"><a href="#View不需要关心Model类型的结构" class="headerlink" title="View不需要关心Model类型的结构"></a><code>View</code>不需要关心<code>Model</code>类型的结构</h3><p>我们现在将移动到<code>MVC</code>的另一端并为我们的应用程序创建<code>Model</code>类型。</p><p>如果您查看上面的自定义视图的代码，您将看到它具有扁平结构。那个类所拥有的所有东西仅仅是到<code>UILabel</code>的<code>UIOutlet</code>。</p><p>这并不意味着我们的<code>Model</code>类型需要具有相同的扁平结构。也不意味着如果我们最终得到的<code>Model</code>类型不能反映其扁平结构时<br>需要更新我们的视图。</p><p>这个概念是<code>MVC</code>和<code>MVVM</code>的核心。</p><p><strong><code>View</code>和<code>Model</code>类型完全脱离开</strong>。前者仅关注如何向用户呈现信息。后者，只关心如何在内部表示数据。</p><p>他们不需要彼此了解任何事情，也不需要以任何方式相互映射。他们甚至可能以完全不同的方式表示信息。</p><p>在<code>MVC</code>中，<code>View Controller</code>负责桥接这一间隙。在<code>MVVM</code>中，它将是<code>View Model</code>的责任。</p><p>因此，让我们开始考虑我们的航班信息所需的数据结构。</p><p>一个航班连接着机场，世界上有许多机场。所以我们需要一个机场结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Airport &#123;</span><br><span class="line">let symbol: String</span><br><span class="line">let name: String</span><br><span class="line">let city: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我只创建了我们Demo所需要的属性。当然，你可以添加其他的，并使其中一些甚至有自己的自定义类型。</p><p>航班不仅仅是机场。特定航班在特定时间离开或到达机场。我们可以称这些为端点，一个航班有两个端点：出发和到达。</p><p>所以我们声明一个结构来表示端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Endpoint &#123;</span><br><span class="line">let date: Date</span><br><span class="line">let airport: Airport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，航班由航空公司运营，并有一个识别它的号码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Flight &#123;</span><br><span class="line">let airline: String</span><br><span class="line">let number: String</span><br><span class="line">let departure: Endpoint</span><br><span class="line">let arrival: Endpoint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们看一下我们小巧的应用程序的设计，我们需要最后一个属性。</p><p>航班有持续时间。抛开我们想要在屏幕上显示它的事实来说，持续时间是航班的属性，因此它属于这个模型。<br>例如，将来我们可能会使用持续时间对航班进行排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Flight &#123;</span><br><span class="line">let airline: String</span><br><span class="line">let number: String</span><br><span class="line">let departure: Endpoint</span><br><span class="line">let arrival: Endpoint</span><br><span class="line"></span><br><span class="line">var duration: TimeInterval &#123;</span><br><span class="line">return arrival.date.timeIntervalSince(departure.date)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两件事很重要：</p><ul><li>这些<code>Model</code>类型的结构与<code>View</code>的结构不同。虽然<code>View</code>是扁平的，但我们的<code>Model</code>类型按层次结构组织（请参见下图）</li><li>数据表示也不同。虽然我们的<code>View</code>以格式化字符串的形式显示所有内容，但在我们的<code>Model</code>类型中，我们有<code>Date</code>和      <code>TimeInterval</code>类型。数据表示和数据可视化是分开的。无论<code>View</code>可能需要什么，该<code>Model</code>都使用最佳类型进行表示</li></ul><figure class="image-box">                <img src="image/The-data-model-layer-of-the-app.png" alt="" title="" class="">                <p></p>            </figure><h3 id="View-Model以最终格式向View提供数据"><a href="#View-Model以最终格式向View提供数据" class="headerlink" title="View Model以最终格式向View提供数据"></a><code>View Model</code>以最终格式向<code>View</code>提供数据</h3><p>现在让我们使用<code>View Model</code>桥接<code>Model</code>类型和<code>View</code>之间的间隙。</p><p>如上所述，<code>View Model</code>是用于将数据传递给<code>View</code>的简单类型。因此，他们需要以<code>View</code>所需的格式向<code>View</code>提供数据。</p><p>我们的<code>View</code>需要其<code>UILabel</code>的字符串，没有别的。</p><p>这正是我们的<code>View Model</code>需要提供的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension FlightCardView &#123;</span><br><span class="line">struct ViewModel &#123;</span><br><span class="line">let airportSymbols: String</span><br><span class="line">let departureDay: String</span><br><span class="line">let departureAirport: String</span><br><span class="line">let airline: String</span><br><span class="line">let flightNumber: String</span><br><span class="line">let duration: String</span><br><span class="line">let arrivalDay: String</span><br><span class="line">let arrivalAirport: String</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如您所看到的，我们的<code>View Model</code>是一个结构体，因此它是一个惰性值类型：</p><ul><li>它没有行为表现</li><li>它不会自己访问<code>Model</code></li><li>它没有收到回调和通知</li><li>它不会进行网络请求</li><li>它不会更新<code>View</code></li></ul><p>所有这些职责保留在<code>Model Controller</code>和<code>View Controller</code>中。</p><p>此外，我们的<code>View Model</code>的所有属性都是<code>String</code>类型，这个很重要。</p><p><code>View</code>仅涉及数据可视化，而不涉及数据转换。组合字符串或格式化数据不是它的职责。</p><p>我们的<code>FlightCardView</code>需要已经采用适合其<code>UILabel</code>的最终格式的数据。</p><p>此<code>ViewModel</code>是<code>FlightCardView</code>类的一部分。因此，它是<code>FlightCardView</code>的子类型。<br>我通常将这些类型放在单独的扩展中以便更好地组织代码。您也可以直接在<code>FlightCardView</code>中声明它们。<br>这只是一种风格问题。</p><p>无论哪种方式，此<code>View Model</code>的<code>scope name</code>是<code>FlightCardView.ViewModel</code>。<br>这清楚地表明这个结构的唯一目的是将数据传递给 <code>FlightCardView</code>。</p><h3 id="将数据类型中的数据转换为View-Model的格式"><a href="#将数据类型中的数据转换为View-Model的格式" class="headerlink" title="将数据类型中的数据转换为View Model的格式"></a>将数据类型中的数据转换为<code>View Model</code>的格式</h3><p>现在我们需要编写将<code>Model</code>类型转换为<code>ViewModel</code>值的代码。</p><p>此代码属于<code>ViewModel</code>本身，这正是它所起到的作用。</p><p>然而有时我们想让一些代码可以在不同的<code>ViewModel</code>中重用。</p><p>例如，我们的应用程序中可能有其他<code>View</code>显示日期。这意味着我们需要更多的<code>ViewModel</code>将<code>Date</code>转换为<br>具有特定格式的<code>String</code>。通常在应用程序的所有屏幕上使用相同的数据格式。</p><p>所以我们可以将这些代码放在<code>Date Extension</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension Date &#123;</span><br><span class="line">var day: String &#123;</span><br><span class="line">let formatter = DateFormatter()</span><br><span class="line">formatter.dateStyle = .full</span><br><span class="line">formatter.timeStyle = .none</span><br><span class="line">return formatter.string(from: self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var time: String &#123;</span><br><span class="line">let formatter = DateFormatter()</span><br><span class="line">formatter.dateFormat = &quot;HH:mm&quot;</span><br><span class="line">return formatter.string(from: self)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们从<code></code>Date中提取<code>day</code>和<code>time</code>，因为在我们的设计中我们需要分别地使用它们。</p><p>同样，<code>duration</code>也有自己的格式。我们需要将用秒来表示的<code>TimeInterval</code>转换成像这样的一个字符串“ 3 小时，10 分钟 ”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension TimeInterval &#123;</span><br><span class="line">var formatted: String &#123;</span><br><span class="line">let secondsInAnHour = 60 * 60</span><br><span class="line">let hours = Int(self) / secondsInAnHour</span><br><span class="line">let minutes = (Int(self) % secondsInAnHour) / 60</span><br><span class="line">return &quot;\(hours) hours, \(minutes) minutes&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的设计中，我们还看到时间和机场信息组合在同一条线上。所以我们需要代码将时间，城市和机场名称组合成一个字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Endpoint &#123;</span><br><span class="line">var timeAndAirport: String &#123;</span><br><span class="line">return date.time</span><br><span class="line">+ &quot; &quot;</span><br><span class="line">+ airport.city</span><br><span class="line">+ &quot;, &quot;</span><br><span class="line">+ airport.name</span><br><span class="line">+ &quot; Airport&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还是将此代码放入<code>Endpoint Extension</code>中，但实际上将它放置在哪里取决于你怎样使用它。</p><p>在这里，我假设我们将在我们的应用程序中的其他地方需要它。如果仅在一个<code>View Model</code>中需要此代码，<br>则最好将其放在这个特定的<code>View Model</code>中。</p><p>请记住，这些<code>Extension</code>是我们的数据格式化代码的一部分。因此，即使我们扩展了<code>Endpoint</code>结构，<br><strong>此代码也不是<code>Model</code>层的一部分</strong>。</p><p>此代码属于<code>View Model</code>层。因此，只有<code>View Model</code>才能使用它。在<code>Model</code>类型中使用这些扩展是一个错误。</p><p>如果您想更正式地强制执行此限制，可以将它们声明为<code>fileprivate</code>，这样它们就不会在应用的其他部分中显示出来。<br>但如果您在同一文件中放置了大量<code>View Model</code>，这也并不总是可行的。</p><p>最终我们可以编写将<code>Flight</code>转换为<code>ViewModel</code>的完整代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">extension FlightCardView.ViewModel &#123;</span><br><span class="line">init(flight: Flight) &#123;</span><br><span class="line">let departure = flight.departure</span><br><span class="line">let arrival = flight.arrival</span><br><span class="line">airportSymbols = departure.airport.symbol + &quot; ➔ &quot; + arrival.airport.symbol</span><br><span class="line">departureDay = departure.date.day</span><br><span class="line">departureAirport = departure.timeAndAirport</span><br><span class="line">airline = flight.airline</span><br><span class="line">flightNumber = flight.number</span><br><span class="line">duration = flight.duration.formatted</span><br><span class="line">arrivalDay = arrival.date.day</span><br><span class="line">arrivalAirport = arrival.timeAndAirport</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">init() &#123;</span><br><span class="line">airportSymbols = &quot;&quot;</span><br><span class="line">departureDay = &quot;&quot;</span><br><span class="line">departureAirport = &quot;&quot;</span><br><span class="line">airline = &quot;&quot;</span><br><span class="line">flightNumber = &quot;&quot;</span><br><span class="line">duration = &quot;&quot;</span><br><span class="line">arrivalDay = &quot;&quot;</span><br><span class="line">arrivalAirport = &quot;&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码接受一个<code>Flight</code>并将其数据转换为<code>FlightCardView</code>所需的各种字符串。</p><p>我还添加了一个初始化器来创建一个空<code>ViewModel</code>。这对于重置<code>FlightCardView</code>中<code>UILabel</code>的值很有用。<br>它还有助于从我们的代码中删除<code>optional</code>。</p><p>我将这些初始化器放在<code>Extension</code>中，因此我们不会丢失<code>ViewModel</code>结构的默认成员初始化器。这可能对单元测试很有用。</p><p>我们现在需要的是将<code>ViewModel</code>传递给<code>FlightCardView</code>的一种方法。 </p><p>我们可以通过一个观察属性<code>viewModel</code>来执行此操作，在每次设置新的<code>viewModel</code>时自动更新<code>UILabel</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FlightCardView: UIView &#123;</span><br><span class="line">@IBOutlet private weak var airportSymbolsLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var departureAirportLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var airlineLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var flightNumberLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var durationLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalDayLabel: UILabel!</span><br><span class="line">@IBOutlet private weak var arrivalAirportLabel: UILabel!</span><br><span class="line"></span><br><span class="line">var viewModel: ViewModel = ViewModel() &#123;</span><br><span class="line">didSet &#123;</span><br><span class="line">airportSymbolsLabel.text = viewModel.airportSymbols</span><br><span class="line">departureDayLabel.text = viewModel.departureDay</span><br><span class="line">departureAirportLabel.text = viewModel.departureAirport</span><br><span class="line">airlineLabel.text = viewModel.airline</span><br><span class="line">flightNumberLabel.text = viewModel.flightNumber</span><br><span class="line">durationLabel.text = viewModel.duration</span><br><span class="line">arrivalDayLabel.text = viewModel.arrivalDay</span><br><span class="line">arrivalAirportLabel.text = viewModel.arrivalAirport</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将来，我们还可以使用此<code>View</code>显示除<code>Flight</code>结构之外的数据。我们需要做的只是为<code>ViewModel</code>添加一个新的初始化器。</p><p>没有其他代码会改变，<code>FlightCardView</code>不会，<code>Flight</code>的结构也不会，甚至<code>ViewModel</code>结构都不会改变。</p><h3 id="View-Controller负责从Model到View的数据流"><a href="#View-Controller负责从Model到View的数据流" class="headerlink" title="View Controller负责从Model到View的数据流"></a><code>View Controller</code>负责从<code>Model</code>到<code>View</code>的数据流</h3><p>我们现在需要组合我们的应用程序，以在屏幕上显示一些信息。</p><p>正如<code>MVC</code>所规定的那样，<code>View Controller</code>传递数据流</p><p>首先，我们需要一些实际数据来显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private extension FlightInfoViewController &#123;</span><br><span class="line">func createFlight() -&gt; Flight &#123;</span><br><span class="line">return Flight(</span><br><span class="line">airline: &quot;Aeroflot&quot;,</span><br><span class="line">number: &quot;AF 3245&quot;,</span><br><span class="line">departure: Endpoint(</span><br><span class="line">date: Date(),</span><br><span class="line">airport: Airport(symbol: &quot;AMS&quot;, name: &quot;Schipol&quot;, city: &quot;Amsterdam&quot;)</span><br><span class="line">),</span><br><span class="line">arrival: Endpoint(</span><br><span class="line">date: Date().addingTimeInterval(3 * 60 * 60 + 10 * 60),</span><br><span class="line">airport: Airport(symbol: &quot;SVO&quot;, name: &quot;Sheremetyevo&quot;, city: &quot;Moscow&quot;)</span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，为了方便起见，我在<code>View Controller</code>中创建了此数据，但这不是正确的位置。<a href="http://matteomanferdini.com/how-to-persist-data-in-ios-apps-using-property-lists-and-the-correct-architecture-for-handling-persistent-storage/" target="_blank" rel="noopener">数据应来自<code>Model Controller</code></a>，<br>从磁盘或网络检索数据的代码通常驻留在<code>Model Controller</code>中。</p><p>现在<code>View Controller</code>所有需要做的是初始化<code>ViewModel</code>并将其传递给它的<code>FlightCardView</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FlightInfoViewController: UIViewController &#123;</span><br><span class="line">@IBOutlet private weak var cardView: FlightCardView!</span><br><span class="line"></span><br><span class="line">override func viewDidLoad() &#123;</span><br><span class="line">super.viewDidLoad()</span><br><span class="line">let flight = createFlight()</span><br><span class="line">cardView.viewModel = FlightCardView.ViewModel(flight: flight)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在我们编写的所有代码中，只有2行属于<code>View Controller</code>。</p><p>与您通常在<code>iOS</code>应用中看到的<code>Massive View Controller</code>完全不同。</p><p><a href="https://github.com/matteom/FlightInfo" target="_blank" rel="noopener">您可以在<code>GitHub</code>上找到此示例的完整代码</a>。</p><h3 id="惰性View-Model的优点"><a href="#惰性View-Model的优点" class="headerlink" title="惰性View Model的优点"></a>惰性<code>View Model</code>的优点</h3><p>正如您所看到的，惰性<code>View Model</code>的优点很多：</p><ul><li>我们尊重<code>MVC</code>的结构和职责划分</li><li><code>View</code>和数据完全脱离开</li><li>无法访问特定视图的内部实现</li><li><code>View Controller</code>具有更少的职责和较少的代码</li><li><code>View</code>可以跨屏幕甚至跨项目重复使用</li><li>扩展<code>View Model</code>有助于为完全不同类型的数据重用相同的<code>View</code></li><li><code>View Model</code>代码是容易测试的，而无需像<code>mock</code>那样测试两次</li></ul><p>原文地址：<a href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" target="_blank" rel="noopener">https://matteomanferdini.com/mvvm-pattern-ios-swift/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragmatic实用主义  </span><br><span class="line">approach 接近,方法  </span><br><span class="line">controversy 论战  </span><br><span class="line">shortcoming 缺点  </span><br><span class="line">definitely 肯定的  </span><br><span class="line">functional 有用的，实用的  </span><br><span class="line">concrete 实在的，具体的，混泥土  </span><br><span class="line">violate 违反，违背  </span><br><span class="line">interpret 解释，说明，翻译  </span><br><span class="line">dictate 指示，指定，指令</span><br><span class="line">extensively 广大地</span><br><span class="line">discern 区分，辨别</span><br><span class="line">trivial 不重要的，琐碎的</span><br><span class="line">populate 居住于，构成人口</span><br><span class="line">explicitly 明白地,明确地</span><br><span class="line">optimal 最理想的，最佳的</span><br><span class="line">impact 影响，冲击</span><br><span class="line">derive 源于，得到</span><br><span class="line">aim 针对，以···为目标</span><br><span class="line">accurate 精准的，准确的</span><br><span class="line">vocal 口头的</span><br><span class="line">proponent 支持者，拥护者</span><br><span class="line">roundup 综述，集拢</span><br><span class="line">skeptical 怀疑性的</span><br><span class="line">implication 影响</span><br><span class="line">downside 下降趋势，缺点</span><br><span class="line">inherently 天性地,固有地</span><br><span class="line">problematic 成问题的，有疑问的</span><br><span class="line">contemplate 深思, 细想</span><br><span class="line">intricate 错综复杂的</span><br><span class="line">can of worms 会造成更多问题</span><br><span class="line">pandora&apos;s box 潘多拉盒子,灾难之源</span><br><span class="line">paradigm 范例</span><br><span class="line">incidentally 偶然地, 不经意地</span><br><span class="line">beast 野兽</span><br><span class="line">illustrate 说明, 阐明</span><br><span class="line">concept 概念，观念</span><br><span class="line">disjoint 解体，使脱臼</span><br><span class="line">hierarchy 等级制度</span><br><span class="line">visualize 形象化, 设想</span><br><span class="line">sole  唯一的，仅有的</span><br><span class="line">separately 分别地，个别地</span><br><span class="line">restriction 约束，限制</span><br><span class="line">reside 居住，定居</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> iOS </tag>
            
            <tag> MVVM </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>也来写一写我理解中的代码布局、xib布局以及storyboard布局</title>
      <link href="/2016/06/08/%E4%B9%9F%E6%9D%A5%E5%86%99%E4%B8%80%E5%86%99%E6%88%91%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%E3%80%81xib%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Astoryboard%E5%B8%83%E5%B1%80/"/>
      <url>/2016/06/08/%E4%B9%9F%E6%9D%A5%E5%86%99%E4%B8%80%E5%86%99%E6%88%91%E7%90%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B8%83%E5%B1%80%E3%80%81xib%E5%B8%83%E5%B1%80%E4%BB%A5%E5%8F%8Astoryboard%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前几天在CocoaChina上看了一篇关于代码布局、xib布局以及storyboard布局的争论，我也参与了其中，大半夜的写出了我自己的理解，结果一个误操作，打了十几分钟的字，就被自己丢失掉了（哎，再一次上了没有保存的当！）。不过本着要发表点自己意见的心态， 还是再次花了十几分钟，重新发表了自己的想法。自己总算参与了iOS开发大军的互喷中。</p><h3 id="为什么有人不喜欢xib和storyboard？"><a href="#为什么有人不喜欢xib和storyboard？" class="headerlink" title="为什么有人不喜欢xib和storyboard？"></a>为什么有人不喜欢xib和storyboard？</h3><p>看了网上很多人的评论，我总结了下，90%的开发认为：</p><ol><li>xib和storyboard布局，没有代码布局看着方便，在xib和storyboard上看UI布局的比较费时；</li><li>xib和storyboard布局，容易冲突，多人协作的时候容易抓狂；</li><li>xib和storyboard布局，不方便维护，后期需求修改的时候没有代码布局修改方便；</li></ol><p>其他的一些观点，我就不列举了。</p><p>有位朋友这样说</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对于支持xib的，我只想说，别坑自己人。</span><br><span class="line">团队开发矛盾就在这时候体现出来了。</span><br><span class="line">以后去了插件化公司你就会明白为什么不让你用xib了。</span><br><span class="line">之前公司所有分配的项目都要求打包成静态库或者动态库，而且不允许打包bundle，统一使用主框架下的图片。</span><br><span class="line">我看看你们傻眼不？</span><br></pre></td></tr></table></figure><p>对于这位朋友的观点，我的想法是类似于架构设计，要有远见，但是也不能过度设计。因地制宜，杀鸡不用牛刀。</p><h3 id="我自己的一些观点"><a href="#我自己的一些观点" class="headerlink" title="我自己的一些观点"></a>我自己的一些观点</h3><p>就个人观点， storyboard，xib 和代码， 都有各自适合的场景。</p><p>在我的理解中， UI 是分成<strong>UI 逻辑</strong>和<strong>UI 布局</strong>， 然而， sb 和 xib，以及代码， 都只是 UI 布局这个环节。</p><p>我个人倾向于 sb， 为什么呢？</p><ol><li>sb 更加直观， 对于整个项目来说， 一个完美的流程图及时呈现在你面前， 你肯定对 整个项目的掌握了然于胸。</li><li>sb 实现起来更快。不论是添加控件，还是给控件布局，sb 都会很 nice 的。</li><li>sb 减少了开发的工作。（我说的只是减少， 不是完全没了）sb 能够很好的把布局工作从代码中拿出来， 让我们的代码只专注于我们的业务和逻辑。我的开发理念是， 能少写一行代码的就不能多写一行。能把事情交给 apple 做的， 我就不会自己来做。</li></ol><p>和代码布局相比起来，</p><ol><li>代码布局不直观， 流程得看代码。（不要说整个项目都是一个人从头到尾做的，自己很清楚之类的。这儿主要讨论团队开发）</li><li>代码布局太费时了。<br>用代码布局， 首先要写添加这个控件的代码， 然后写这个控件的布局，或者写约束，相对 sb 来说，的确太耗时了。<br>不过可能大家要说 sb 修改起来太麻烦了。 其实就我个人观点，sb 相对于代码来说，修改起来反而更加简单。因为要修改或者删除 sb 里面的控件的时候， 如果理不清的时候， 直接删掉所有控件， 重新添加控件， 重现布局，也不是一个多大的事。<br>然而， 如果用代码的话， 大家首先得理解这段代码的含义， 然后还要考虑这个代码能不能改， 能不能删，思考的时间绝对不少了。 而且，一般大家也不敢随便动其他人写的代码， 怕改出问题。</li><li>代码布局效率高，sb 效率低。<br>我觉得编译时期， 的确 sb布局被代码完爆。 不过在运行的时候， 个人觉得差不太多， 估计代码布局会好点。但是相对于程序结构来说， 我觉得完全没必要。</li><li>代码布局相对于 sb 布局的团队合作来说， 要略胜一筹。但是 sb 布局的冲突， 其实从技术上是可以规避的， 不过具体方式就不在这儿讨论了</li></ol><p>在 UI 的实现上，我在概念上将 UI分成 UI 逻辑和 UI 布局， 我觉得苹果之所以出 xib 和 sb，就是想把 UI 布局的工作给抽出来，让我们只关注与业务和逻辑。不要被布局给困扰。</p><p>所以我在实现UI 的时候， 基本上我的代码只看得到 UI 逻辑部分， 而布局相关的代码完全没了。</p><h3 id="一些大牛的观点"><a href="#一些大牛的观点" class="headerlink" title="一些大牛的观点"></a>一些大牛的观点</h3><p><a href="https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/" target="_blank" rel="noopener">https://onevcat.com/2013/12/code-vs-xib-vs-storyboard/</a></p><p><a href="http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/" target="_blank" rel="noopener">http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/</a></p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>虽然上面我说了我个人倾向于sb，不过还是得看项目，不同的项目要因地制宜。</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown基本语法</title>
      <link href="/2016/05/20/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2016/05/20/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="1-‘-‘标题-类-Setext-形式"><a href="#1-‘-‘标题-类-Setext-形式" class="headerlink" title="1. ‘=/-‘标题 (类 Setext 形式)"></a>1. ‘=/-‘标题 (类 Setext 形式)</h2><blockquote><h1 id="Setext-1级标题"><a href="#Setext-1级标题" class="headerlink" title="Setext 1级标题  "></a>Setext 1级标题  </h1><h2 id="Setext-2级标题"><a href="#Setext-2级标题" class="headerlink" title="Setext 2级标题  "></a>Setext 2级标题  </h2></blockquote><p>类 Setext 形式是用底线的形式，利用 <strong>等号(=)</strong> 表示最高阶标题 和 <strong>减号(-)</strong> 表示第二阶标题<br>任何数量的 <strong>=</strong> 和 <strong>-</strong> 都可以有效果。  </p><pre><code>This is an H1=============This is an H2-------------</code></pre><h2 id="2-‘-’标题-类-Atx-形式"><a href="#2-‘-’标题-类-Atx-形式" class="headerlink" title="2. ‘#’标题 (类 Atx 形式)"></a>2. ‘#’标题 (类 Atx 形式)</h2><blockquote><h1 id="Atx-1级标题"><a href="#Atx-1级标题" class="headerlink" title="Atx 1级标题"></a>Atx 1级标题</h1><h2 id="Atx-2级标题"><a href="#Atx-2级标题" class="headerlink" title="Atx 2级标题"></a>Atx 2级标题</h2><h3 id="Atx-3级标题"><a href="#Atx-3级标题" class="headerlink" title="Atx 3级标题"></a>Atx 3级标题</h3><h4 id="Atx-4级标题"><a href="#Atx-4级标题" class="headerlink" title="Atx 4级标题"></a>Atx 4级标题</h4><h5 id="Atx-5级标题"><a href="#Atx-5级标题" class="headerlink" title="Atx 5级标题"></a>Atx 5级标题</h5><h6 id="Atx-6级标题"><a href="#Atx-6级标题" class="headerlink" title="Atx 6级标题"></a>Atx 6级标题</h6></blockquote><p>类 Atx 形式则是在行首插入 1～6 个 <strong>#</strong> ，对应到标题 1～6 阶  </p><pre><code>非闭合方式：# 这是 H1## 这是 H2###### 这是 H6闭合方式（首尾对称）：# 这是 H1 ### 这是 H2 ######## 这是 H6 ######     </code></pre><h2 id="3-斜体"><a href="#3-斜体" class="headerlink" title="3. 斜体"></a>3. 斜体</h2><blockquote><ul><li><em>1个星号</em></li><li><em>1个下划线</em></li></ul></blockquote><p>首尾用 1 个 <strong>星号( * )</strong> 或者 <strong>下划线( _ )</strong> 包含一段文本</p><pre><code>*身正不怕影子斜*_身正不怕影子斜_</code></pre><h2 id="4-粗体"><a href="#4-粗体" class="headerlink" title="4. 粗体"></a>4. 粗体</h2><blockquote><ul><li><strong>2个星号</strong></li><li><strong>2个下划线</strong></li></ul></blockquote><p>首尾用 2 个 <strong>星号( * )</strong> 或者 <strong>下划线( _ )</strong> 包含一段文本</p><pre><code>**粗不粗**__粗不粗__</code></pre><h2 id="5-粗斜体"><a href="#5-粗斜体" class="headerlink" title="5. 粗斜体"></a>5. 粗斜体</h2><blockquote><ul><li><strong><em>3个星号</em></strong></li><li><strong><em>3个下划线</em></strong></li></ul></blockquote><p>首尾用 3 个 <strong>星号( * )</strong> 或者 <strong>下划线( _ )</strong> 包含一段文本</p><pre><code>***又粗又斜有木有***___又粗又斜有木有___</code></pre><h2 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6. 无序列表"></a>6. 无序列表</h2><blockquote><ul><li>无序列表1</li></ul><ul><li>无序列表2</li></ul><ul><li>无序列表3  </li></ul></blockquote><p>无序列表使用 <strong>星号( * )</strong> 、<strong>加号( + )</strong> 或是 <strong>减号( - )</strong> 作为列表标记</p><pre><code>*   Red*   Green*   Blue等同于：+   Red+   Green+   Blue也等同于：-   Red-   Green-   Blue</code></pre><h2 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7. 有序列表"></a>7. 有序列表</h2><blockquote><ol><li>有序立标1</li><li>有序列表2</li><li>有序列表3</li></ol></blockquote><p>有序列表则使用数字接着一个英文句点：<strong>“1.”</strong> <strong>“2.”</strong> <strong>“3.”</strong></p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><h2 id="8-链接"><a href="#8-链接" class="headerlink" title="8. 链接"></a>8. 链接</h2><blockquote><p><a href="http://www.markdown.cn" target="_blank" rel="noopener">Markdown</a></p></blockquote><p>格式：[链接显示的文字](URL地址)</p><pre><code>例如：[Markdown](http://www.markdown.cn)</code></pre><h2 id="9-图片"><a href="#9-图片" class="headerlink" title="9. 图片"></a>9. 图片</h2><blockquote><figure class="image-box">                <img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=a4e83ab404d79123f4ed9c26cc5d32e7/7c1ed21b0ef41bd5c306824859da81cb39db3d30.jpg" alt="我是一张快乐的图片" title="" class="">                <p>我是一张快乐的图片</p>            </figure></blockquote><p>格式：![图片的替代文字](图片地址 “可选文字”)</p><pre><code>例如：![](https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/              w%3D268%3Bg%3D0/sign=79cf53f2074f78f0800b9df5410a6d68/              00e93901213fb80ef9ceac7132d12f2eb938947d.jpg)</code></pre><h2 id="10-引用（Blockquote）"><a href="#10-引用（Blockquote）" class="headerlink" title="10. 引用（Blockquote）"></a>10. 引用（Blockquote）</h2><h5 id="普通区块引用"><a href="#普通区块引用" class="headerlink" title="普通区块引用"></a>普通区块引用</h5><blockquote><p>别人笑我太疯癫<br>  我笑他人看不穿<br>  不见武林豪杰墓<br>  无花无酒锄作田  </p></blockquote><pre><code>Markdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式，自己先断好行，然后在每行的最前面加上 &gt; ： &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing.  Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</code></pre><h5 id="区块引用可以嵌套（引用内引用）"><a href="#区块引用可以嵌套（引用内引用）" class="headerlink" title="区块引用可以嵌套（引用内引用）"></a>区块引用可以嵌套（引用内引用）</h5><blockquote><p>别人笑我太疯癫，<br>  我笑他人看不穿，<br>  不见武林豪杰墓，<br>  无花无酒锄作田</p><blockquote><p>你是唐伯虎？</p></blockquote><p>哇呀呀呀呀~，好！实不相瞒，小弟我就是人称玉树临风胜潘安，一朵梨花压海棠的小淫虫周伯通！</p></blockquote><pre><code>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ：This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><h5 id="区块内使用其他的-Markdown-语法"><a href="#区块内使用其他的-Markdown-语法" class="headerlink" title="区块内使用其他的 Markdown 语法"></a>区块内使用其他的 Markdown 语法</h5><blockquote><h6 id="我是被块引用的标题。"><a href="#我是被块引用的标题。" class="headerlink" title="我是被块引用的标题。"></a>我是被块引用的标题。</h6><ol><li>我是被块引用的列表1。</li><li>我是被块引用的列表2。</li></ol><p>什么？块引用还能引用代码：</p><pre><code>void blockquoteFunction() { printf &quot;我就是被块引用的代码&quot;;}</code></pre></blockquote><pre><code>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：&gt; ## 这是一个标题。&gt; &gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><h2 id="11-代码"><a href="#11-代码" class="headerlink" title="11. 代码"></a>11. 代码</h2><h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><blockquote><p>一个简单的函数：<code>void main() { print &quot;Hello, markdown!&quot;; }</code>，在同一行就可以写完</p></blockquote><p>如果要标记一小段行内代码，你可以用 <strong>反引号( ` )</strong> 把它包起来  </p><pre><code>一个简单的函数：`void main() { print &quot;Hello, markdown!&quot;; }`，在同一行就可以写完</code></pre><h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><p>如果要标记多行代码，你可以用3个 <strong>反引号( ` )</strong> 来开启和结束代码区段  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">print &quot;Hello, markdown!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式3"><a href="#方式3" class="headerlink" title="方式3"></a>方式3</h4><p>使用 1 个制表符建立代码区块  </p><pre><code>void main() {    print &quot;Hello, markdown!&quot;;}</code></pre><h4 id="方式4"><a href="#方式4" class="headerlink" title="方式4"></a>方式4</h4><p>缩进 4 个空格建立代码区块</p><pre><code>void main() {    print &quot;Hello, markdown!&quot;;}</code></pre><h2 id="12-表格"><a href="#12-表格" class="headerlink" title="12. 表格"></a>12. 表格</h2><blockquote><p>最常见的Markdown格式选项和键盘快捷键(引用自百度百科)</p></blockquote><table><thead><tr><th>&gt; 输出后的效果</th><th style="text-align:center">Markdown</th><th style="text-align:right">快捷键</th></tr></thead><tbody><tr><td>Bold</td><td style="text-align:center"><strong>text</strong></td><td style="text-align:right">Ctrl/⌘ + B</td></tr><tr><td>Emphasize</td><td style="text-align:center"><em>text</em></td><td style="text-align:right">Ctrl/⌘ + I</td></tr><tr><td>Link</td><td style="text-align:center">[title](http://)</td><td style="text-align:right">Ctrl/⌘ + K</td></tr><tr><td>Inline Code</td><td style="text-align:center"><code>code</code></td><td style="text-align:right">Ctrl/⌘ + Shift + K</td></tr><tr><td>Image</td><td style="text-align:center">![alt](http://)</td><td style="text-align:right">Ctrl/⌘ + Shift + I</td></tr><tr><td>List</td><td style="text-align:center">* item</td><td style="text-align:right">Ctrl + L</td></tr><tr><td>Blockquote</td><td style="text-align:center">&gt; quote</td><td style="text-align:right">Ctrl + Q</td></tr><tr><td>H1</td><td style="text-align:center"># Heading</td><td style="text-align:right"></td></tr><tr><td>H2</td><td style="text-align:center">## Heading</td><td style="text-align:right">Ctrl/⌘ + H</td></tr><tr><td>H3</td><td style="text-align:center">### Heading</td><td style="text-align:right">Ctrl/⌘ + H (x2)</td></tr></tbody></table><p>表格格式如下，用 &gt;=3 个 <strong>减号( - )</strong> 分割表头和内容，每一列用 <strong>或( | )</strong> 分割。<br>  默认居左，居中在分割线 <strong>( — )</strong> 两边加上 <strong>英文冒号( : )</strong>，居右在分割线 <strong>( — )</strong> 右边加上 <strong>英文冒号( : )</strong></p><pre><code>表头1     | 表头2           | 表头3---      | :-------------: | ----:默认居左   | 居中 :---:      | 居右 ---:居左 :--- | 居中 :---:      | 居右 ---:</code></pre><h2 id="13-转义符-反斜杠"><a href="#13-转义符-反斜杠" class="headerlink" title="13. 转义符 反斜杠( \ )"></a>13. 转义符 <strong>反斜杠( \ )</strong></h2><p>Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code>\   反斜杠`   反引号*   星号_   下划线{}  花括号[]  方括号()  括弧#   井号+   加号-   减号.   英文句点!   感叹号</code></pre><h2 id="14-分隔线"><a href="#14-分隔线" class="headerlink" title="14. 分隔线"></a>14. 分隔线</h2><blockquote><p>我是一个快乐的句子，我下面有好多线。</p><hr><hr><hr><hr><hr></blockquote><p>用三个以上的 <strong>星号( * )</strong>、<strong>加号( + )</strong> 或是 <strong>下划线( _ )</strong> 来建立一个分隔线。  </p><pre><code>行内不能有其他内容，你也可以在星号或是减号中间插入空格，下面每种写法都可以建立分隔线：**** * *******_ _ _______</code></pre>]]></content>
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>细说 iOS 中的 http 协议</title>
      <link href="/2016/02/02/%E7%BB%86%E8%AF%B4%20iOS%20%E4%B8%AD%E7%9A%84%20http%20%E5%8D%8F%E8%AE%AE/"/>
      <url>/2016/02/02/%E7%BB%86%E8%AF%B4%20iOS%20%E4%B8%AD%E7%9A%84%20http%20%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>http 协议在我们的工作中，基本上99%的 app 都是无法避免的，http 协议的重要性，不亚于 UIKit 的存在。</p><p>当我们在工作中，对 http 协议的理解层度，很多时候决定了我们项目架构的深度和稳定性；<br>当我们在<strong>找工作</strong>中，对 http 协议的理解层度，很多时候也决定了我们应聘的职位 level。</p><p>在这篇文章中，我会详细的、系统的讲解下 http 协议，以及 http 协议在 iOS 中相关的一些知识。</p><blockquote><ul><li>http 协议细说</li><li>http 协议在 iOS 中如何存在的</li></ul></blockquote><h3 id="http-协议"><a href="#http-协议" class="headerlink" title="http 协议"></a>http 协议</h3><p>关于 http 协议，</p>]]></content>
      
      <categories>
          
          <category> iOS </category>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机图形渲染的流程</title>
      <link href="/2015/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
      <url>/2015/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%9A%84%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p><a href="https://bbs.feng.com/read-htm-tid-6880069.html" target="_blank" rel="noopener">原文链接</a></p><p>计算机的绘图过程可以简单用流水线来说明，而产品（数据）就是经过流水线作业（渲染）到屏幕的图像。这条流水线可以简化为（本文的概念）：绘图位置座标指定；着色指定；输出指定；图1简单解释了这一个流水线过程。计算机绘图需要一个输入绘图数据，这个数据可以是用户指定的，也可以是操作系统决定的，也可以是混合的。这些数据是分组的。</p><p>座标生成：当绘图数据送入座标生成系统后，流水线就会对其进行座标分派，图1右上的线框图抽象描述了这个过程。</p><p>着色指定：当座标系统生成出带座标的绘图数据后就需要送入着色器，着色器指定了这些线框的填充颜色或纹理。</p><p>渲染：着色器将绘图数据加上着色数据后就被送入渲染器，渲染器根据绘图数据描述，将像素填充到描述的线框组里并送入帧缓存，然后然后送入显示器，显示器获取到帧缓存的数据后再根据数据的描述来绘图到屏幕上。</p><figure class="image-box">                <img src="2015-08-12/1.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="像素与点（point）与点（dot）"><a href="#像素与点（point）与点（dot）" class="headerlink" title="像素与点（point）与点（dot）"></a>像素与点（point）与点（dot）</h3><p>像素与点（point），点（dot）这三个单位很容易令人混淆，原因在于它们在很多场合上是可以互换的。但是本文需要区分这两者的概念。</p><p>像素指的是一种数据结构，这个数据结构包含了RGB三个数据，分别对应的是红色，绿色，蓝色。我们说一张计算机生成的位图时，我们会说这图是多少像素x多少像素，例如800x600像素。值得注意的是，像素没有一个固定的尺寸单位，它只是一个抽象概念。</p><p>点（dot）指的是显示器屏幕的点或打印的点，是具体指代的事物。我们想说的DPI即dot per inch，每英寸多少个点。一般来说1个点对应一个像素，常见的打印尺寸是72DPI，即每英寸72点，也就是包含72个像素的数据。当像素被计算机输出成点投射都屏幕或纸面上时，它才具备了尺寸的概念，即点（dot）。</p><p>点（point）指的是座标点，是一个数据结构，包含了两个数据（或三个）X和Y(和Z)座标。绘图数据里是包含了这个座标数据的。对于没有使用HiDPI的操作系统来说，一个座标点对应一个像素。</p><h3 id="点（point）不一定等于像素"><a href="#点（point）不一定等于像素" class="headerlink" title="点（point）不一定等于像素"></a>点（point）不一定等于像素</h3><p>一般来说，点（dot）与像素是可以互换指代的，而且我们在Retina的概念被提出前一直这样使用它们。但是，现在这两个概念必须要区分出来。像素只是一个描述RGB的数据结构，它没有任何尺寸单位，它更不是一个矩形。当像素被输出到屏幕或纸张上时，我们应该用点来指代这种含有颜色，有尺寸的具体事物。</p><p>普通的显示屏幕或打印机，我们会说屏幕上的一个点（dot）是由一个像素（RGB数据）组成的，打印后的点是由一个像素经过色彩转换（CMYK数据）组成的。</p><p>对于打印机来说，一般的DPI是72。也就是指我们在显示器屏幕上看到720x720像素的位图，在打印出来后的面积是10x10英寸，但是屏幕上的位图面积并不会跟打印出来的面积一致。因为屏幕上的一个点与打印的点的尺寸不一样。</p><p>PPI指的是每英寸多少像素，与DPI有一定概念上的区别。PPI一般指的是屏幕的点密度，DPI指的是打印点的密度。PPI不是固定的，不同屏幕尺寸结合不同的分辨率会有不同的PPI，但是DPI则是相对固定在72。</p><p>HiDPI是苹果的一项绘图技术，结合这种技术，计算机座标系统上的一个点（point）不再对应一个像素，一般来说会是一个座标点对应四个像素，而一个像素对应屏幕的一个物理点（dot）。</p><p>由于像素是一组色彩数据，所以绘图数据在经过着色器后才包含了它。举个例子，绘图数据在送入着色器前是描述一个100x100的矩形，经过着色器指定色彩属性后会被送入一个HiDPI系统，这个系统将200x200个像素的数据添加到绘图数据里。在经过渲染器后，相当于将200x200个像素填充进100x100这个矩形线框。</p><figure class="image-box">                <img src="2015-08-12/2.png" alt="Picture description" title="" class="">                <p>Picture description</p>            </figure><h3 id="帧缓存与显示器屏幕"><a href="#帧缓存与显示器屏幕" class="headerlink" title="帧缓存与显示器屏幕"></a>帧缓存与显示器屏幕</h3><p>帧缓存是储存计算机渲染后的图形数据的，这些数据包括座标，像素，分辨率等等。。简单来说就是描述图象的数据，当这些描述数据送入显示器后，显示器就知道怎么绘图了。</p><p>一般来说的屏幕分辨率指的是渲染器生产出来的像素数据排列，例如1280x800像素。值得注意的是这个屏幕分辨率与显示器屏幕的物理点排列没关系的。屏幕分辨率是可设置的，显示器的物理点排列是固定的。例如帧缓存里的分辨率是1280x800像素，但是显示器屏幕是1920x1200点排列的，那么显示器会怎么将帧缓存里的数据呈现到屏幕上呢？答案是通过自适应放缩，是经过显示器内部芯片来转换的。</p><p>13寸的RMBP在分辨率设置里是这样描述的，看起来像1280x800像素，看起来像1440x900像素。我们需要这样理解，1280x800像素是相对于旧款不带Retina的机器，也就是绘图数据送入着色器前的座标系统与渲染后的座标是1:1对应的参考值。实际上在经过渲染后，它的实际像素是2560x1600，也就是帧缓存里是数据是2560x1600像素。同样地看起来1440x900像素实际渲染后的像素是2880x1800。由于13寸的屏幕实际点排列是2560x1600，所以帧缓存2880x1800像素在输出到屏幕后会被自适应缩放掉。</p><h3 id="DPI与Retina"><a href="#DPI与Retina" class="headerlink" title="DPI与Retina"></a>DPI与Retina</h3><p>操作系统标准的桌面打印DPI是72，但是随着HiDPI技术和高PPI屏幕出现后，这个标准也许会有一定的变化。我们在Retina的OS X下用Photoshop新建一个文件时默认的DPI指定在144上了，这是标准转变的一个信号。</p><p>在没有使用类似HiDPI技术的操作系统上，屏幕分辨率对应的打印DPI是72。使用HiDPI的Retina机器的打印DPI是144，用以保证在统一尺下具有更多的点密度。这点对于印前工作非常重要。</p>]]></content>
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形渲染 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>Eden Huang</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>@card{</p><p><strong>姓名</strong>：黄聪<br><strong>标签</strong>：iOS、Swift、Flutter、Dart、JS、Java、微信小程序<br><strong>邮箱</strong>：<a href="mailto:huangcong520@icloud.com" target="_blank" rel="noopener">huangcong520@icloud.com</a></p><p>@right{</p><p><strong>个人资料</strong></p><p>}</p><p>}</p><p>@card{</p><p><strong>本博客主题</strong>：<a href="https://github.com/codefine/hexo-theme-mellow" target="_blank" rel="noopener">hexo-theme-mellow</a></p><p>}</p><hr><p>@timeline{</p><h5 id="工作履历"><a href="#工作履历" class="headerlink" title="工作履历"></a>工作履历</h5><p>@item{</p><h6 id="2016-09"><a href="#2016-09" class="headerlink" title="2016.09"></a>2016.09</h6><p><strong>神马专车</strong><br>神马专车</p><p>}</p><p>@item{</p><h6 id="2014-10-2016-05"><a href="#2014-10-2016-05" class="headerlink" title="2014.10 ~ 2016.05"></a>2014.10 ~ 2016.05</h6><p><strong>地利集团</strong><br>农丰网</p><p>}</p><p>@item{</p><h6 id="2013-04-2014-10"><a href="#2013-04-2014-10" class="headerlink" title="2013.04 ~ 2014.10"></a>2013.04 ~ 2014.10</h6><p><strong>图丰信息（成都）有限责任公司</strong><br>Stamigo</p><p>}</p><p>@item{</p><h6 id="2011-12-2013-04"><a href="#2011-12-2013-04" class="headerlink" title="2011.12 ~ 2013.04"></a>2011.12 ~ 2013.04</h6><p><strong>Myriad Group</strong><br>Pivot、Messager</p><p>}</p><p>@item{</p><h6 id="2011-06-2011-11"><a href="#2011-06-2011-11" class="headerlink" title="2011.06 ~ 2011.11"></a>2011.06 ~ 2011.11</h6><p><strong>成都融创天下科技有限公司</strong><br>监控摄像头客户端</p><p>}</p><p>}</p><hr><h3 id="我的朋友们-排名不分先后"><a href="#我的朋友们-排名不分先后" class="headerlink" title="我的朋友们(排名不分先后)"></a><strong>我的朋友们(排名不分先后)</strong></h3><p>@column-3{</p><p>@card{</p><p>@center{</p><p><a href="http://wwhy.tech/" target="_blank" rel="noopener">成都老刘</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>}</p><hr><h3 id="大佬们"><a href="#大佬们" class="headerlink" title="大佬们"></a><strong>大佬们</strong></h3><p>@column-3{</p><p>@card{</p><p>@center{</p><p><a href="https://onevcat.com/" target="_blank" rel="noopener">onevcat</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>@card{</p><p>@center{</p><p><a href="http://blog.devtang.com/" target="_blank" rel="noopener">唐巧</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>@card{</p><p>@center{</p><p><a href="https://blog.ibireme.com/" target="_blank" rel="noopener">YYKit作者</a><br>iOS相关技术Blog</p><p>}</p><p>}</p><p>}</p>]]></content>
    </entry>
    
    <entry>
      <title>自定义页面演示</title>
      <link href="/custom/index.html"/>
      <url>/custom/index.html</url>
      <content type="html"><![CDATA[<h1 id="双栏结构"><a href="#双栏结构" class="headerlink" title="双栏结构"></a>双栏结构</h1><p>@column-2{</p><p>@card{</p><h1 id="左"><a href="#左" class="headerlink" title="左"></a>左</h1><p>}</p><p>@card{</p><h1 id="右"><a href="#右" class="headerlink" title="右"></a>右</h1><p>}</p><p>}</p><h1 id="控制文本对齐方式的三栏结构"><a href="#控制文本对齐方式的三栏结构" class="headerlink" title="控制文本对齐方式的三栏结构"></a>控制文本对齐方式的三栏结构</h1><p>@column-3{</p><p>@card{</p><p>左</p><p>}</p><p>@card{</p><p>@center{</p><p>中</p><p>}</p><p>}</p><p>@card{</p><p>@right{</p><p>右</p><p>}</p><p>}</p><p>}</p><p>@timeline{</p><h5 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h5><p>@item{</p><h6 id="11月6日"><a href="#11月6日" class="headerlink" title="11月6日"></a>11月6日</h6><p>为 <code>Card theme</code> 添加 <code>page layout</code>。<br>第二行测试</p><p>}</p><p>@item{</p><h6 id="11月20日"><a href="#11月20日" class="headerlink" title="11月20日"></a>11月20日</h6><p>另一个 Time line .<br>第二行测试</p><p>}</p><p>@item{</p><h6 id="11月20日-1"><a href="#11月20日-1" class="headerlink" title="11月20日"></a>11月20日</h6><p>还有一个 Time line .<br>第二行测试</p><p>}</p><p>}</p>]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>阅读</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[<p>@card{</p><h3 id="在读书籍"><a href="#在读书籍" class="headerlink" title="在读书籍"></a><strong>在读书籍</strong></h3><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img3.doubanio.com/view/subject/l/public/s25648004.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论（原书第3版）》</a></p><p>}</p><p><strong>内容简介：</strong><br>在有关算法的书中，有一些叙述非常严谨，但不够全面；另一些涉及了大量的题材，但又缺乏严谨性。本书将严谨性和全面性融为一体，深入讨论各类算法，并着力使这些算法的设计和分析能为各个层次的读者接受。全书各章自成体系，可以作为独立的学习单元；算法以英语和伪代码的形式描述，具备初步程序设计经验的人就能看懂；说明和解释力求浅显易懂，不失深度和数学严谨性。</p><p>}</p><p>}</p><hr><p>@card{</p><h3 id="已读书籍"><a href="#已读书籍" class="headerlink" title="已读书籍"></a><strong>已读书籍</strong></h3><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img3.doubanio.com/view/subject/l/public/s28100915.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/24720270/" target="_blank" rel="noopener">《Objective-C高级编程》</a></p><p>}</p><p><strong>内容简介：</strong><br>本书在苹果公司公开的源代码基础上，深入剖析了对应用于内存管理的ARC 以及应用于多线程开发的Blocks 和GCD。这些新技术看似简单，实则非常容易成为技术开发的陷阱，开发者仅靠阅读苹果公司的文档是不够的。<br>本书适合有一定基础的iOS 开发者阅读。</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="https://img1.doubanio.com/view/subject/l/public/s27552168.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/25829244/" target="_blank" rel="noopener">《Effective Objective-C 2.0》</a></p><p>}</p><p><strong>内容简介：</strong><br>《effective objective-c 2.0：编写高质量ios与os x代码的52个有效方法》是世界级c++开发大师scott meyers亲自担当顾问编辑的“effective software development series”系列丛书中的新作，amazon全五星评价。从语法、接口与api设计、内存管理、框架等7大方面总结和探讨了objective-c编程中52个鲜为人知和容易被忽视的特性与陷阱。书中包含大量实用范例代码，为编写易于理解、便于维护、易于扩展和高效的objective-c应用提供了解决方案。</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img1.doubanio.com/view/subject/l/public/s6908318.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/2334288/" target="_blank" rel="noopener">《大话设计模式》</a></p><p>}</p><p><strong>内容简介：</strong><br>本书通篇都是以情景对话的形式，用多个小故事或编程示例来组织讲解GOF(设计模式的经典名著——Design Patterns:Elements of Reusable Object-Oriented Software，中译本名为《设计模式——可复用面向对象软件的基础》的四位作者EIich Gamma、Richard Helm、Ralph Johnson，以及John Vlissides，这四人常被称为Gang of Four，即四人组，简称GoF)总结的23个设计模式。</p><p>}</p><p>}</p><hr><p>@card{</p><h3 id="待读书籍"><a href="#待读书籍" class="headerlink" title="待读书籍"></a><strong>待读书籍</strong></h3><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="https://img1.doubanio.com/view/subject/l/public/s1495029.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全（第2版）》</a></p><p>}</p><p><strong>内容简介：</strong><br>这是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。</p><p>}</p><p>}</p>]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>study</title>
      <link href="/study/index.html"/>
      <url>/study/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>Hexo Themes</title>
      <link href="/themes/index.html"/>
      <url>/themes/index.html</url>
      <content type="html"><![CDATA[<p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-anisina.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Haojen/hexo-theme-Anisina" target="_blank" rel="noopener">hexo-theme-Anisina</a><br><a href="https://haojen.github.io/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-claudia.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Haojen/hexo-theme-Claudia" target="_blank" rel="noopener">hexo-theme-Claudia</a><br><a href="https://haojen.github.io/Claudia-theme-blog/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-melody.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a><br><a href="https://molunerfinn.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-miho.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/WongMinHo/hexo-theme-miho" target="_blank" rel="noopener">hexo-theme-miho</a><br><a href="https://blog.minhow.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-vexo.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/yanm1ng/hexo-theme-vexo" target="_blank" rel="noopener">hexo-theme-vexo</a><br><a href="https://yanm1ng.github.io/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-paperbox.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank" rel="noopener">hexo-theme-paperbox</a><br><a href="http://www.sun11.me/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-diaspora.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/Fechin/hexo-theme-diaspora" target="_blank" rel="noopener">hexo-theme-diaspora</a><br><a href="http://fech.in/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-ztopic.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/wa-ri/hexo-theme-ztopic" target="_blank" rel="noopener">hexo-theme-ztopic</a><br><a href="http://zccblog.cn/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-indigo.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a><br><a href="https://www.imys.net/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-mellow.jpg" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/codefine/hexo-theme-mellow" target="_blank" rel="noopener">hexo-theme-mellow</a><br><a href="http://blog.lujingtao.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p><p>@column-2{</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-material.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">hexo-theme-material</a><br><a href="https://blog.viosey.com/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>@card{</p><figure class="image-box">                <img src="screenshot/theme-spfk.png" alt="" title="" class="">                <p></p>            </figure><p>@center{</p><p><a href="https://github.com/luuman/hexo-theme-spfk" target="_blank" rel="noopener">hexo-theme-spfk</a><br><a href="https://luuman.github.io/" target="_blank" rel="noopener">Preview</a></p><p>}</p><p>}</p><p>}</p>]]></content>
    </entry>
    
  
</search>
