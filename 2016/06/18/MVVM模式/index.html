<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    
    
    <title>Swift中iOS应用程序的MVVM模式 | Hello World | 路漫漫其修远兮，吾将上下而求索</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="keywords" content="Swift,iOS,MVVM,翻译">
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/third-party/swipebox.min.css?v=1.3.2">
    <link rel="stylesheet" href="/css/style.css?v=1.3.2">
    
    <script type="text/javascript">
        // Data Center
        var DC = {
            reward:	true,
            lv: JSON.parse('{"enable":false,"app_id":null,"app_key":null,"icon":true}'),
            v: JSON.parse('{"enable":false,"appid":null,"appkey":null,"notify":true,"verify":true,"placeholder":"give me some sugers plz...","avatar":"wavatar"}'),
            g: JSON.parse('{"enable":false,"lazy":true,"owner":"codefine","repo":"gitment","oauth":{"client_id":null,"client_secret":null},"perPage":10}'),
            d: JSON.parse('{"app_id":null}')
        };
    </script>
    <script type="text/javascript">
        window.lazyScripts=[];
    </script>
    
</head>


<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      
      <img src="/img/brand.jpg" class="brand-bg">
      
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Eden Huang</h5>
          <a href="mailto:huangcong520@icloud.com" title="huangcong520@icloud.com" class="mail">
            
              <span>h</span>
            
              <span>u</span>
            
              <span>a</span>
            
              <span>n</span>
            
              <span>g</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>n</span>
            
              <span>g</span>
            
              <span>5</span>
            
              <span>2</span>
            
              <span>0</span>
            
              <span>@</span>
            
              <span>i</span>
            
              <span>c</span>
            
              <span>l</span>
            
              <span>o</span>
            
              <span>u</span>
            
              <span>d</span>
            
              <span>.</span>
            
              <span>c</span>
            
              <span>o</span>
            
              <span>m</span>
            
          </a>
        </hgroup>
        
        <ul class="menu-link">
          
              <li>
                <a href="https://github.com/ioshc" target="_blank">
                  <i class="icon icon-lg icon-github"></i>
                </a>
              </li>
            
        </ul>
        
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="">
              <a href="/reading"  >
                <i class="icon icon-lg icon-book"></i>
                阅读
              </a>
            </li>
        
            <li class="">
              <a href="/study"  >
                <i class="icon icon-lg icon-question-circle"></i>
                学习
              </a>
            </li>
        
            <li class="">
              <a href="/themes"  >
                <i class="icon icon-lg icon-file-image-o"></i>
                主题
              </a>
            </li>
        
            <li class="">
              <a href="/about"  >
                <i class="icon icon-lg icon-user"></i>
                关于
              </a>
            </li>
        
            <li class="">
              <a href="/custom"  >
                <i class="icon icon-lg icon-file"></i>
                测试页面
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row clearfix">
        <a href="javascript:;" class="header-icon pull-left waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">
            <span>Swift中iOS应用程序的MVVM模式</span>
            
        </div>
        
        <a href="javascript:;" id="site_search_btn" class="header-icon pull-right waves-effect waves-circle waves-light">
            <i class="icon icon-lg icon-search"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">
    <img src="/img/banner.jpg" class="header-bg">
    <div class="container fade-scale">
        <h1 class="title">Swift中iOS应用程序的MVVM模式</h1>
        <h5 class="subtitle">
            
                <time datetime="2016-06-18T14:23:41.000Z" itemprop="datePublished" class="page-time">
  2016-06-18
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/翻译/">翻译</a></li></ul>

            
        </h5>
        
    </div>
    

</header>

<div id="site_search">
    <div class="search-title clearfix">
        <span class="pull-left">
          <i class="icon icon-lg icon-search"></i>
        </span>
        <input type="text" id="local-search-input" name="q" results="0" placeholder="search my blog..." class="form-control pull-left"/>
        <a href="javascript:;" class="close pull-right waves-effect waves-circle waves-light">
          <i class="icon icon-lg icon-close"></i>
        </a>
    </div>
    <div id="local-search-result"></div>
</div>


<div class="container body-wrap">
    <article id="post-MVVM模式"
  class="post-article article-type-post" itemprop="blogPost">
    <div class="post-card">
        <h1 class="post-card-title">Swift中iOS应用程序的MVVM模式</h1>
        <div class="post-meta">
            <time class="post-time" title="2016-06-18 22:23:41" datetime="2016-06-18T14:23:41.000Z"  itemprop="datePublished">2016-06-18</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/翻译/">翻译</a></li></ul>



            

            


            
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            
            <h3 id="Swift中iOS应用程序的MVVM模式：一个实用的方法"><a href="#Swift中iOS应用程序的MVVM模式：一个实用的方法" class="headerlink" title="Swift中iOS应用程序的MVVM模式：一个实用的方法"></a><code>Swift</code>中<code>iOS</code>应用程序的<code>MVVM</code>模式：一个实用的方法</h3><figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/The-MVVM-Pattern-for-iOS-Apps-in-Swift-a-Pragmatic-Approach.png" class="swipebox" title=undefined><img src="image/The-MVVM-Pattern-for-iOS-Apps-in-Swift-a-Pragmatic-Approach.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<p><code>MVVM</code>最近在<code>iOS</code>开发社区中变得很流行。</p>
<p>但它并非没有争议，</p>
<p>我就是其中一个，我对<code>MVVM</code>的一些实现持保留意见，但我也认为它的一些想法是合理的。</p>
<p>在谈到缺点时，我不仅仅站在理论的角度，</p>
<p>我在真实的项目中也体验过它们。</p>
<p>我参与了一些跟随其中一些想法的项目，其中一个项目来自一家知名公司，结果该项目相对于计划延迟了几年发布。</p>
<p>几年时间，</p>
<p>你想想看。</p>
<p>虽然我不能说只有这一个原因，但所有这些原因中肯定包含对<code>MVVM</code>的实践。</p>
<p>在本文中，我们将看到：</p>
<ul>
<li><code>MVVM</code>和<code>MVC</code>之间的关系</li>
<li><code>MVVM</code>的详细信息</li>
<li><code>MVVM</code>模式中，网络请求代码应该放在哪里</li>
<li><code>MVVM</code>和实用的响应式编程框架，如<code>RxSwift</code></li>
<li>不同方法的优缺点</li>
<li>一个避免了许多问题的实用的方法，并包含具体的例子</li>
</ul>
<h3 id="在MVC模式中，View不应该知道相关App中Model的任何信息"><a href="#在MVC模式中，View不应该知道相关App中Model的任何信息" class="headerlink" title="在MVC模式中，View不应该知道相关App中Model的任何信息"></a>在<code>MVC</code>模式中，<code>View</code>不应该知道相关App中<code>Model</code>的任何信息</h3><p>让我们从我们试图解决的实际问题开始。</p>
<p>我在<code>iOS</code>应用中看到的最常见的<code>MVC</code>模式违规之一发生在<code>View</code>与应用的<code>Model</code>类型相关联时。</p>
<p>像任何重大错误一样，我过去也犯过这个错误，所以我很清楚它的样子。</p>
<p><a href="http://matteomanferdini.com/the-concepts-at-the-foundation-of-any-ios-app/" target="_blank" rel="noopener">我在文章中经常指出<code>MVC</code>模式的各个层</a>，我可以将<code>iOS</code>应用中的大部分问题都联系到违反这些原则的行为。</p>
<p>作为回顾，<code>iOS MVC</code>模式将我们的类型划分为4个（而不仅仅是3个）层：</p>
<ul>
<li><code>Model</code>类型代表数据以及业务逻辑</li>
<li><code>Model Controller</code>是与设备的接口，并以特定于应用的方式处理<code>Model</code>类型。例如保存App的状态，<br>  保存数据到磁盘或访问网络</li>
<li><code>View</code>在屏幕上展示信息并允许用户交互</li>
<li><code>View Controller</code>是<code>View</code>和<code>MVC</code>模式中较低层之间的桥梁。它将用于显示的数据传送给<code>View</code>，<br>  并解释用户的交互，指定应用程序屏幕的流程</li>
</ul>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/The-basic-structure-of-the-MVC-pattern-in-iOS.png" class="swipebox" title=undefined><img src="image/The-basic-structure-of-the-MVC-pattern-in-iOS.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<p><a href="https://matteomanferdini.com/understanding-the-core-architectural-principles-of-ios-development-with-a-practical-example/" target="_blank" rel="noopener">我已经写了很多关于这个的文章</a></p>
<p>正如我们在上面的观点中看到的，<code>View</code>需要从<code>View Controller</code>接收数据用于显示，它不直接访问<code>Model</code>。</p>
<h3 id="Model类型和View之间的桥接有其自身的问题"><a href="#Model类型和View之间的桥接有其自身的问题" class="headerlink" title="Model类型和View之间的桥接有其自身的问题"></a><code>Model</code>类型和<code>View</code>之间的桥接有其自身的问题</h3><p>将数据传递给<code>View Controller</code>中的<code>View</code>的问题来自以下事实，因为那样做会很容易：</p>
<ul>
<li>将<code>Model</code>类型直接传递给<code>View</code>以在屏幕上渲染</li>
<li>让<code>View Controller</code>对<code>View</code>的内部实现了解太多</li>
</ul>
<p>开发者经常做任何一个（或都做），因为它们是快速的解决方案。</p>
<p>但是两者都会引发问题，因为它们导致模块之间的耦合。第一个导致<code>Model</code>类型和<code>View</code>之间的耦合，<br>第二个在<code>View Controller</code>和<code>View</code>之间。</p>
<p>耦合使我们的模块更难以重用并且更容易破坏。</p>
<p>让我们更详细地看看这两个问题，</p>
<p>开发者经常将<code>Model</code>类型直接传递给<code>View</code>，以便<code>View</code>可以自己读取这些数据的格式。<br>但是如果你看看<code>MVC</code>中的角色，格式化数据并不是<code>View</code>的责任</p>
<p>这会在<code>View</code>和<code>Model</code>类型之间创建耦合，这意味着：</p>
<ul>
<li><code>View</code>很难在不同的屏幕之间以及不同的应用之间复用，如果要使用相同的<code>View</code>来展示另一个数据类型，事情就变得复杂了。<br>  这个视图需要知道两种不同的类型，并且能够区分它们。如果你想要在其他项目中重用这个<code>View</code>，则需要携带所有这些依赖项。</li>
</ul>
<ul>
<li><code>View</code>的实现捆绑到<code>Model</code>的实现，这意味着<code>Model</code>的任何改变都可能会破坏<code>View</code>的代码，然后需要重写代码。<br>  这可能不是那么简单，特别是如果<code>View</code>依赖于多个<code>Model</code>类型。</li>
</ul>
<p><code>MVC</code>模式使<code>View</code>独立于<code>Model</code>类型来解决这个问题，在<code>iOS</code>版<code>MVC</code>方案中，<code>View</code>和<code>Model</code>之间没有箭头。</p>
<p>这意味着<strong><code>View</code>仅获取简单格式的数据</strong></p>
<p>事实上，如果你查看<code>UIKit</code>框架的所有<code>UIView</code>，它们就会以这种方式工作。<code>Label</code>只需要一个简单的<code>String</code>来展示，  <code>Switch</code>、<code>Slider</code>、<code>ProgressView</code>只需要简单的类型，如<code>Bool</code>、<code>Int</code>、<code>Float</code>。</p>
<p>像<code>UITableView</code>这样复杂的视图会附加到<code>DataSource</code>。<br>为此，它让<code>Cell</code>来显示，请注意，<code>UITableView</code>不会要求数据，它只要求已经填充的<code>Cell</code>。</p>
<p>通过这种方式，<code>UITableView</code>可以保持通用，你可以将之用于应用中的任何<code>Model</code>类型。</p>
<h3 id="View不应该暴露其内部实现"><a href="#View不应该暴露其内部实现" class="headerlink" title="View不应该暴露其内部实现"></a><code>View</code>不应该暴露其内部实现</h3><p>当<code>View Controller</code>或其它对象对<code>View</code>的内部实现了解太多时，会发生对<code>MVC</code>模式的另一种违反。</p>
<p>你可以在<code>UITableView</code>的<code>DataSource</code>中经常看到这一点。</p>
<p><code>DataSource</code>需要在将<code>Cell</code>返回给<code>UITableView</code>之前用数据填充<code>Cell</code>。</p>
<p>一个常见的错误是让<code>DataSource</code>访问<code>Cell</code>的子视图来填充数据，</p>
<p>因此，<code>DataSource</code>经常访问<code>Cell</code>的<code>UILabel</code>、<code>UIImageView</code>和其它子视图以给它们赋值。<br>这可以通过<code>UIOutlet</code>发生，或者更糟糕的是，使用<code>UIview.viewWithTag()</code>方法，</p>
<p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/TableView_iPhone/TableViewCells/TableViewCells.html#//apple_ref/doc/uid/TP40007451-CH7-SW18" target="_blank" rel="noopener">你甚至可以在苹果的官方文档中找到它们</a></p>
<p>这里的问题是这又引入了耦合，当我们更改<code>Cell</code>的实现时，我们会破坏访问它的所有<code>DataSource</code>。</p>
<p><code>UILabel</code>和其它子视图是<code>View</code>内部实现的一部分，任何对象都不应该依赖于另一个对象的内部实现。</p>
<p>事实上，<code>UIOutlet</code>甚至不应该暴露出来，我明确地将我代码中的<code>UIOutlet</code>都标记为<code>private</code>，<br><strong><code>UIOutlet</code>的所有者是唯一访可以问它的人</strong>。</p>
<p>这里的解决方案和上面的一样，<code>Cell</code>是一个<code>View</code>，和其它的<code>View</code>一样，因此，<a href="https://matteomanferdini.com/the-correct-way-to-display-lists-in-ios-and-what-many-developers-do-wrong/" target="_blank" rel="noopener">它只接受一种简单的数据格式</a>。<br>然后，自己有填充内部<code>UIOutlet</code>的责任。</p>
<h3 id="在View-Controller中做数据转换不是最优的"><a href="#在View-Controller中做数据转换不是最优的" class="headerlink" title="在View Controller中做数据转换不是最优的"></a>在<code>View Controller</code>中做数据转换不是最优的</h3><p>所以关于<code>View</code>的指导方针是：</p>
<ul>
<li>不要传递任何<code>Model</code>类型给它们</li>
<li>不要访问它们的内部实现</li>
</ul>
<p>正如我们所看到的，两者的解决方式是相同的：<strong><code>View</code>应该接受简单类型的数据</strong>。</p>
<p>因此，我们需要将<code>Model</code>类型的数据转换为简单类型，</p>
<p>这个转换过程通常在哪里完成？</p>
<p>确切地说：在<code>View Controller</code>内部。</p>
<p>诱惑有时候是把它放到<code>Model</code>类型中，但是<code>Model</code>类型不应该知道如何向用户呈现数据。</p>
<p>同样的数据在应用程序不同的部分可以有不同的呈现方式，这样就赋予<code>Model</code>类型太多职责而违反了<code>MVC</code>模式。</p>
<p><code>Model Controller</code>也不是正确的位置，它们只处理数据但并不关心他们怎么呈现。</p>
<p>现在就剩下<code>View Controller</code>了，但这同样也有问题。</p>
<p>要清楚，这并不是错误的。如果你遵循上面的<code>View</code>准则并将<code>MVC</code>定义的职责分开，那么你已经比很多复制-粘贴开发人员更胜一筹。</p>
<p>但是在<code>View Controller</code>中放置数据转换并不是最佳选择：</p>
<ul>
<li><p>首先，我们知道在<code>View Controller</code>中的代码往往会增长很多，<a href="https://matteomanferdini.com/how-to-structure-the-code-of-ios-apps/" target="_blank" rel="noopener">因为它在<code>iOS</code>中起着核心的作用</a>，<br>  因此，在可能的情况下，最好避免对这个问题作出贡献</p>
</li>
<li><p>这同样也影响代码重用，如果我们想在另一个界面使用相同的<code>View</code>，我们需要找到一种在<code>View Controller</code><br>  之间共享转换代码的方式</p>
</li>
</ul>
<p>也有一些这方面的解决方案。</p>
<p>例如，我们可以使用<code>Swift Extension</code>对相关的转换代码进行分组，这是一种有效的方法。</p>
<p>另一种方法是遵循<code>MVVM</code>模式。</p>
<h3 id="MVVM模式是MVC模式的扩展"><a href="#MVVM模式是MVC模式的扩展" class="headerlink" title="MVVM模式是MVC模式的扩展"></a><code>MVVM</code>模式是<code>MVC</code>模式的扩展</h3><p><a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel" target="_blank" rel="noopener">MVVM模式</a>由微软公司开发。</p>
<p>是的，我知道，这很震惊。</p>
<p><code>MVVM</code>模式源于<code>MVC</code>模式，它旨在解决在<code>View Controller</code>内部发生模型对象转换的问题。</p>
<p><code>MVVM</code>的想法很简单。</p>
<p><strong>我们在<code>MVC</code>模式中的<code>View</code>和<code>View Controller</code>之间引入一个新层</strong>，负责处理数据转换。</p>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/The-basic-structure-of-the-MVVM-pattern-in-iOS.png" class="swipebox" title=undefined><img src="image/The-basic-structure-of-the-MVVM-pattern-in-iOS.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<p>（是的，我知道这个图解不准确，请继续阅读。）</p>
<p>听起来相当简单，不是吗？</p>
<p>不幸的是，在<code>iOS</code>中，<code>MVVM</code>模式有其自身的问题。</p>
<p>像上面这样的图的缺点是它没有显示这些层之间的相互作用的所有细微差别，</p>
<p>这留下太多需要自我理解的东西。</p>
<p>如果你阅读关于<code>MVVM</code>的<code>iOS</code>开发文章，你会发现围绕它的不同想法，甚至<code>MVVM</code>呼声最高的支持者也不同意其中的一些观点。</p>
<p><a href="http://khanlou.com/2015/12/mvvm-is-not-very-good/" target="_blank" rel="noopener">本文对<code>MVVM</code>的分歧有很好的总结</a>，</p>
<p>这是让我长时间对<code>MVVM</code>持怀疑态度的原因之一，直到我找到了更实用的方法。</p>
<p>让我们看看这些问题。</p>
<h3 id="View-Model应该是值类型，而不是引用类型"><a href="#View-Model应该是值类型，而不是引用类型" class="headerlink" title="View Model应该是值类型，而不是引用类型"></a><code>View Model</code>应该是值类型，而不是引用类型</h3><p>我在<code>MVVM</code>中发现的第一个重大问题是将<code>View Model</code>作为引用类型。</p>
<p>这可能看起来像一个小细节，但是它有很大的影响。</p>
<p>在这个话题上，我和Andy Matuschack站在同一阵营。他非常好的讨论了我真正推荐的<a href="https://academy.realm.io/posts/andy-matuschak-controlling-complexity/" target="_blank" rel="noopener">引用类型和值类型之间的区别</a>。</p>
<p>这个观点是：</p>
<ul>
<li>值类型是惰性的，只能有一个所有者，这使得更容易推断它们的代码</li>
<li>引用类型可以拥有许多所有者，它们接受来至其它对象的方法调用，全局通知，回调，<code>KVO</code>通知等，这使得很难推断其代码</li>
</ul>
<p>这显示了<code>View Model</code>作为参考类型如何产生巨大差异。<code>View Model</code>成为有状态对象，可以通过代码的不同部分进行更新，<br>这通常会导致意外行为和奇怪的Workaround。</p>
<p>突然之间，你在<code>MVC</code>中有第三层，它本身就是行为。</p>
<p>您可以在<a href="https://www.objc.io/issues/13-architecture/mvvm/" target="_blank" rel="noopener"><code>iOS</code>的<code>MVVM</code>的大多数图解</a>中清楚地看到这一点，这通常采用以下形式：</p>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/A-wrong-diagram-for-MVVM-in-iOS.png" class="swipebox" title=undefined><img src="image/A-wrong-diagram-for-MVVM-in-iOS.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<p>我只是为了向您展示相关信息，但我建议不要采用这种方法。</p>
<p>在这里你可以清楚地看到：</p>
<ul>
<li><code>View Model</code>是一个行为层。它<strong>拥有</strong><code>Model</code>并通过某种形式的通知或回调进行更新</li>
<li>甚至<code>Model</code>类型也是引用类型，这是它们能够向<code>View Model</code>发送信号的唯一方式</li>
<li>它似乎完全忽略了<code>MVC</code>的<code>Model Controller</code>层，实际上，<code>View Model</code>似乎取代了该方案中的<code>Model Controller</code></li>
</ul>
<p>行为<code>View Model</code>有很大的缺点。首先，你可以看到，在没有更多职责的情况下，它们至少有两个职责，<br>它们在将数据传递给<code>View</code>之前检索数据并对其进行格式化。</p>
<p>实际上，Andy Matuschak本人在他关于<a href="https://academy.realm.io/posts/andy-matuschak-refactor-mega-controller/" target="_blank" rel="noopener">重构<code>Mega Controller</code>的一次谈话中</a>发表了这番话。<br>在45:08时，他解释了<code>MVVM</code>中数据转换部分是正确的，但其余的都是错误的。</p>
<p>观看整个演讲，最大程度地影响了我写<code>iOS</code>应用程序方式。</p>
<p>因此，<code>View Model</code>作为参考类型天生存在问题。</p>
<p>但这只是冰山一角。</p>
<h3 id="网络代码不应该进入View-Model"><a href="#网络代码不应该进入View-Model" class="headerlink" title="网络代码不应该进入View Model"></a>网络代码不应该进入<code>View Model</code></h3><p><code>View Model</code>的另一个问题是，这个版本的<code>MVVM</code>的一些支持者认为，<a href="http://artsy.github.io/blog/2015/09/24/mvvm-in-swift/" target="_blank" rel="noopener">网络代码应该放在<code>View Model</code>中</a>。</p>
<p>在这里，我们看到将<code>View Model</code>作为引用类型的一个重要影响。如果它们是值类型，则这是不可能的。</p>
<p>在您的<code>MVVM</code>版本中，网络代码放在<code>View Model</code>中是可以理解的：</p>
<ul>
<li>没有考虑<code>Model Controller</code>的存在</li>
<li>明确声明<code>View Model</code>的行为以及通过回调或某种形式的通知来更新<code>View Controller</code></li>
</ul>
<p>这使得<code>View Controller</code>和<code>View Model</code>成为网络代码的唯一候选者。</p>
<p>由于每个人都知道<code>View Controller</code>已经太大了，因此网络代码自然而然的放在了<code>View Model</code>中。</p>
<p>这会在难以理解的对象之间创建一个非常复杂的回调网络，并导致许多错误。</p>
<p>我们甚至没有考虑单元测试，这会造成更多问题。</p>
<p>我已经证明<a href="http://matteomanferdini.com/network-requests-rest-apis-ios-swift/" target="_blank" rel="noopener">网络代码应该转移到<code>Model Controller</code>内部</a>，并且<code>Model type</code>应该是惰性值类型。</p>
<p>我们是否解决了这些问题？</p>
<p>还没有。</p>
<p>此版本的<code>MVVM</code>鼓励另一种模式，这对我来说像是<code>iOS</code>中的异步代码的灾难之源：<code>函数响应式编程</code>。</p>
<h3 id="函数响应式编程框架隐藏了幕后的大量复杂性"><a href="#函数响应式编程框架隐藏了幕后的大量复杂性" class="headerlink" title="函数响应式编程框架隐藏了幕后的大量复杂性"></a><code>函数响应式编程</code>框架隐藏了幕后的大量复杂性</h3><p>与此版本的<code>MVVM</code>经常相关的一件事是<code>函数响应式编程</code>（<code>FRP</code>）。</p>
<p><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener">FRP</a>是异步数据流的编程范例，它使用函数式编程的构建块，如map，reduce和filter。</p>
<p>在<code>iOS</code>中，<code>FRP</code>通常有不同的风格：</p>
<ul>
<li><code>RxSwift</code></li>
<li><code>ReactiveSwift</code>  和  <code>ReactiveCocoa</code></li>
</ul>
<p>使用<code>FRP</code>框架时，您的代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let searchResults = searchBar.rx.text.orEmpty</span><br><span class="line">    .throttle(0.3, scheduler: MainScheduler.instance)</span><br><span class="line">    .distinctUntilChanged()</span><br><span class="line">    .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in</span><br><span class="line">        if query.isEmpty &#123;</span><br><span class="line">            return .just([])</span><br><span class="line">        &#125;</span><br><span class="line">        return searchGitHub(query)</span><br><span class="line">            .catchErrorJustReturn([])</span><br><span class="line">    &#125;</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line"> </span><br><span class="line">searchResults</span><br><span class="line">    .bind(to: tableView.rx.items(cellIdentifier: &quot;Cell&quot;)) &#123;</span><br><span class="line">        (index, repository: Repository, cell) in</span><br><span class="line">        cell.textLabel?.text = repository.name</span><br><span class="line">        cell.detailTextLabel?.text = repository.url</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>
<p>我最初写了这段代码的详细分析，然后意识到这是浪费你我的时间。</p>
<p>我只想写几个注意事项，</p>
<p>这段代码隐藏了很多幕后的复杂性，即使在不需要异步代码的地方，也有很多异步操作和回调在后台进行。</p>
<p>实际上，您可以在<code>RxSwift</code>的文档页面中清楚地看到它，<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Why.md" target="_blank" rel="noopener">它涉及<code>binding</code>, <code>retrie</code>, <code>delegate</code>, <code>KVO</code>, <code>Notification</code></a>等。</p>
<p><code>FRP</code>背后的想法是你编写“声明性”代码并放弃对异步操作的控制。这正是我对<code>FRP</code>不喜欢的，它的代码不够明确。</p>
<p><code>FRP</code>粉丝通常回答：“但看看我写的代码有多少，它就像魔法一样！“</p>
<p>对我来说，这正是问题所在。</p>
<p>在软件开发中，<strong>如果某些东西看起来太聪明或看起来像魔术，那可能是个坏主意</strong></p>
<p>这种方法使编写代码变得非常容易，但：</p>
<blockquote>
<p>Programs must be written for people to read, and only incidentally for machines to execute.<br>程序必须写得能供人阅读，机器执行只是附带  </p>
<ul>
<li>Harold Abelson</li>
</ul>
</blockquote>
<p>这是一个定义问题，<code>FRP</code>的支持者会告诉你，这段代码正是如此：完全可读。</p>
<p>对我而言，事实并非如此。它达到如此高的抽象水平，很难知道它究竟做了什么。</p>
<p>此外，尝试在几个月内调试问题，此时您将无法了解所有这些异步代码的工作原理。正如Brian Kernighan曾经说过：</p>
<blockquote>
<p>每个人都知道调试的难度是最初编写程序的两倍。因为，如果您在编写时足够聪明，那么您现在怎么会调试它？</p>
</blockquote>
<p>这一点与上面讨论的相同。这会创建一个复杂的对象网络，它们以自己的方式运行，这使得很难推断出这段代码。</p>
<p>当然，你可以写得很快。但代码是写一次而读很多次。你将为节省时间付出代价。</p>
<p>最后，团队中的每个人都需要学习一个全新的范例。这段代码肯定很短，但<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="noopener"><code>RxSwift</code>的文档肯定不短</a>。</p>
<p>最后一个问题是<code>FRP</code>是一个范例，它的实现是不同的。</p>
<p><a href="https://stackoverflow.com/questions/32542846/reactivecocoa-vs-rxswift-pros-and-cons" target="_blank" rel="noopener">在Stack Overflow上查看关于<code>RxSwift</code>和<code>ReactiveCocoa</code></a>的关于这个问题的答案。它在一开始就说：“比较两个世界是非常困难的”。<br>后来，结论是：“<code>RAC</code>和<code>RxSwift</code>是两个完全不同的野兽”。</p>
<p>所以这些范例不可互换。即使您了解一个<code>FRP</code>框架，当您使用另一个框架时，您可能还需要重新学习所有内容。</p>
<p>最后，选择权归你所有。在我看来，它产生的问题多于解决的问题。</p>
<p>如果你喜欢这种魔法编程，那就去吧。但是你可能就不喜欢我在材料中写的大部分内容。</p>
<p>相反，如果您想要遵循不同的<code>MVC</code>和<code>MVVM</code>方法，请继续阅读。</p>
<h3 id="View-Model作为惰性值类型"><a href="#View-Model作为惰性值类型" class="headerlink" title="View Model作为惰性值类型"></a><code>View Model</code>作为惰性值类型</h3><p>如果我们修改我们的<code>View Model</code>为值类型，我上面说明的所有内容都不再可能。</p>
<p>在<code>View Model</code>中不再有状态，网络和<code>FRP</code>，</p>
<p>这很好。</p>
<p>这种<code>MVVM</code>模式的<code>View Model</code>层变得惰性。因此，它不能是<code>View Controller</code>和<code>Model</code>之间的连接层。</p>
<p><code>View Model</code>变成了一个帮助层，它位于<code>View Controller</code>和<code>View</code>旁边，而不是它们之间。</p>
<p><code>View Model</code>的唯一责任就是以正确的格式将数据传递给<code>View</code>。我们所知道的<code>MVC</code>的各层之间的连接受到尊重：</p>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/A-pragmatic-approach-to-MVVM-in-iOS.png" class="swipebox" title=undefined><img src="image/A-pragmatic-approach-to-MVVM-in-iOS.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<p>您可以看到<code>View Model</code>中没有箭头。这是因为，正如名称所述，它们是模型对象。模型实体是惰性值类型。</p>
<p>但与我们的应用程序的模型类型（代表数据和业务逻辑）不同，<code>View Model</code>代表可视信息。</p>
<p>这允许我们：</p>
<ul>
<li>从<code>View Controller</code>中接管数据格式化的责任</li>
<li>定义简单视图类型以将数据传递给<code>View</code></li>
<li>使转换代码和自定义视图可以在我们的应用程序甚至跨不同项目中重复使用</li>
<li>扩展视图模型，以便相同的自定义视图可以显示不同类型的数据</li>
</ul>
<p>像往常一样，让我们​​看看所有这些理论的实际应用。</p>
<p>我们将构建一个显示航班信息的简单应用程序。</p>
<p>这将允许我显示模型类型，视图模型和转换代码之间的明确分离。</p>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/Design-of-the-MVVM-example-app.png" class="swipebox" title=undefined><img src="image/Design-of-the-MVVM-example-app.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<h3 id="MVVM的基本块是自定义视图"><a href="#MVVM的基本块是自定义视图" class="headerlink" title="MVVM的基本块是自定义视图"></a><code>MVVM</code>的基本块是自定义视图</h3><p>让我们从简单的东西开始吧。</p>
<p>首先，我们在<code>interface builder</code>中为<code>View Controller</code>创建界面。</p>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/UI-for-the-MVVM-example-app-in-Interface-Builder-1024x650.png" class="swipebox" title=undefined><img src="image/UI-for-the-MVVM-example-app-in-Interface-Builder-1024x650.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<p>在这里，我使用简单<code>UIView</code>和<code>UILabel</code>的组合创建了遵循上述设计的卡片。</p>
<p>我使用<code>UIStackView</code>和<code>Auto Layout constraint</code>的组合放置了这些视图。我还为卡片周围的阴影设置了一些<br>用户定义的运行时属性。您可以在图像右侧看到这些值。</p>
<p>但这不是重要的事情。</p>
<p>由于这不是关于<code>Auto Layout</code>和<code>UI</code>的文章，我不会详细介绍。你可以<a href="https://github.com/matteom/FlightInfo" target="_blank" rel="noopener">在Github上找到他们的Xcode项目</a>，<br>并<a href="https://matteomanferdini.com/understanding-the-core-architectural-principles-of-ios-development-with-a-practical-example/" target="_blank" rel="noopener">在这篇文章中较长的讨论</a>，或在<a href="http://matteomanferdini.com/ultimate-course-making-professional-ios-apps/" target="_blank" rel="noopener">我的专业制作iOS应用免费课程</a>。</p>
<p>重要的是，根据我们的<code>MVVM</code>版本，这个<code>View</code>需要有一个自定义类，它隐藏了它的内部实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class FlightCardView: UIView &#123;</span><br><span class="line">	@IBOutlet private weak var airportSymbolsLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var departureDayLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var departureAirportLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var airlineLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var flightNumberLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var durationLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var arrivalDayLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var arrivalAirportLabel: UILabel!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，<code>FlightCardView</code>引用它自己的子视图，在这个例子中都是<code>UILabel</code>，通过<code>UIOutlet</code>连接。</p>
<p>通常看到<code>UIOutlet</code>仅从<code>View Controller</code>到其<code>View</code>中的所有界面元素。但是<code>View</code>也可以拥有到其子视图的<code>UIOutlet</code>。</p>
<p>这是<code>MVVM</code>的基本组成部分。</p>
<p>当<code>View Controller</code>具有到所有在其<code>View</code>中的接口元素的<code>UIOutlet</code>时，这意味着它对该<code>View</code>的内部实现了解太多。<br>所以它违反了我们上面列出的指导方针。</p>
<p>相反，使用自定义视图，<code>View Controller</code>不需要很多<code>UIOutlet</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class FlightInfoViewController: UIViewController &#123;</span><br><span class="line">	@IBOutlet private weak var cardView: FlightCardView!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此示例中，我们的<code>View Controller</code>实际上只有一个<code>UIOutlet</code>。</p>
<h3 id="View不需要关心Model类型的结构"><a href="#View不需要关心Model类型的结构" class="headerlink" title="View不需要关心Model类型的结构"></a><code>View</code>不需要关心<code>Model</code>类型的结构</h3><p>我们现在将移动到<code>MVC</code>的另一端并为我们的应用程序创建<code>Model</code>类型。</p>
<p>如果您查看上面的自定义视图的代码，您将看到它具有扁平结构。那个类所拥有的所有东西仅仅是到<code>UILabel</code>的<code>UIOutlet</code>。</p>
<p>这并不意味着我们的<code>Model</code>类型需要具有相同的扁平结构。也不意味着如果我们最终得到的<code>Model</code>类型不能反映其扁平结构时<br>需要更新我们的视图。</p>
<p>这个概念是<code>MVC</code>和<code>MVVM</code>的核心。</p>
<p><strong><code>View</code>和<code>Model</code>类型完全脱离开</strong>。前者仅关注如何向用户呈现信息。后者，只关心如何在内部表示数据。</p>
<p>他们不需要彼此了解任何事情，也不需要以任何方式相互映射。他们甚至可能以完全不同的方式表示信息。</p>
<p>在<code>MVC</code>中，<code>View Controller</code>负责桥接这一间隙。在<code>MVVM</code>中，它将是<code>View Model</code>的责任。</p>
<p>因此，让我们开始考虑我们的航班信息所需的数据结构。</p>
<p>一个航班连接着机场，世界上有许多机场。所以我们需要一个机场结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Airport &#123;</span><br><span class="line">	let symbol: String</span><br><span class="line">	let name: String</span><br><span class="line">	let city: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我只创建了我们Demo所需要的属性。当然，你可以添加其他的，并使其中一些甚至有自己的自定义类型。</p>
<p>航班不仅仅是机场。特定航班在特定时间离开或到达机场。我们可以称这些为端点，一个航班有两个端点：出发和到达。</p>
<p>所以我们声明一个结构来表示端点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Endpoint &#123;</span><br><span class="line">	let date: Date</span><br><span class="line">	let airport: Airport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，航班由航空公司运营，并有一个识别它的号码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Flight &#123;</span><br><span class="line">	let airline: String</span><br><span class="line">	let number: String</span><br><span class="line">	let departure: Endpoint</span><br><span class="line">	let arrival: Endpoint</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们看一下我们小巧的应用程序的设计，我们需要最后一个属性。</p>
<p>航班有持续时间。抛开我们想要在屏幕上显示它的事实来说，持续时间是航班的属性，因此它属于这个模型。<br>例如，将来我们可能会使用持续时间对航班进行排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Flight &#123;</span><br><span class="line">	let airline: String</span><br><span class="line">	let number: String</span><br><span class="line">	let departure: Endpoint</span><br><span class="line">	let arrival: Endpoint</span><br><span class="line">	</span><br><span class="line">	var duration: TimeInterval &#123;</span><br><span class="line">		return arrival.date.timeIntervalSince(departure.date)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两件事很重要：</p>
<ul>
<li>这些<code>Model</code>类型的结构与<code>View</code>的结构不同。虽然<code>View</code>是扁平的，但我们的<code>Model</code>类型按层次结构组织（请参见下图）</li>
<li>数据表示也不同。虽然我们的<code>View</code>以格式化字符串的形式显示所有内容，但在我们的<code>Model</code>类型中，我们有<code>Date</code>和      <code>TimeInterval</code>类型。数据表示和数据可视化是分开的。无论<code>View</code>可能需要什么，该<code>Model</code>都使用最佳类型进行表示</li>
</ul>
<figure class="image-box">
                <a rel=Swift中iOS应用程序的MVVM模式 href="image/The-data-model-layer-of-the-app.png" class="swipebox" title=undefined><img src="image/The-data-model-layer-of-the-app.png" alt="" title="" class=""></a>
                <p></p>
            </figure>
<h3 id="View-Model以最终格式向View提供数据"><a href="#View-Model以最终格式向View提供数据" class="headerlink" title="View Model以最终格式向View提供数据"></a><code>View Model</code>以最终格式向<code>View</code>提供数据</h3><p>现在让我们使用<code>View Model</code>桥接<code>Model</code>类型和<code>View</code>之间的间隙。</p>
<p>如上所述，<code>View Model</code>是用于将数据传递给<code>View</code>的简单类型。因此，他们需要以<code>View</code>所需的格式向<code>View</code>提供数据。</p>
<p>我们的<code>View</code>需要其<code>UILabel</code>的字符串，没有别的。</p>
<p>这正是我们的<code>View Model</code>需要提供的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">extension FlightCardView &#123;</span><br><span class="line">	struct ViewModel &#123;</span><br><span class="line">		let airportSymbols: String</span><br><span class="line">		let departureDay: String</span><br><span class="line">		let departureAirport: String</span><br><span class="line">		let airline: String</span><br><span class="line">		let flightNumber: String</span><br><span class="line">		let duration: String</span><br><span class="line">		let arrivalDay: String</span><br><span class="line">		let arrivalAirport: String</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如您所看到的，我们的<code>View Model</code>是一个结构体，因此它是一个惰性值类型：</p>
<ul>
<li>它没有行为表现</li>
<li>它不会自己访问<code>Model</code></li>
<li>它没有收到回调和通知</li>
<li>它不会进行网络请求</li>
<li>它不会更新<code>View</code></li>
</ul>
<p>所有这些职责保留在<code>Model Controller</code>和<code>View Controller</code>中。</p>
<p>此外，我们的<code>View Model</code>的所有属性都是<code>String</code>类型，这个很重要。</p>
<p><code>View</code>仅涉及数据可视化，而不涉及数据转换。组合字符串或格式化数据不是它的职责。</p>
<p>我们的<code>FlightCardView</code>需要已经采用适合其<code>UILabel</code>的最终格式的数据。</p>
<p>此<code>ViewModel</code>是<code>FlightCardView</code>类的一部分。因此，它是<code>FlightCardView</code>的子类型。<br>我通常将这些类型放在单独的扩展中以便更好地组织代码。您也可以直接在<code>FlightCardView</code>中声明它们。<br>这只是一种风格问题。</p>
<p>无论哪种方式，此<code>View Model</code>的<code>scope name</code>是<code>FlightCardView.ViewModel</code>。<br>这清楚地表明这个结构的唯一目的是将数据传递给 <code>FlightCardView</code>。</p>
<h3 id="将数据类型中的数据转换为View-Model的格式"><a href="#将数据类型中的数据转换为View-Model的格式" class="headerlink" title="将数据类型中的数据转换为View Model的格式"></a>将数据类型中的数据转换为<code>View Model</code>的格式</h3><p>现在我们需要编写将<code>Model</code>类型转换为<code>ViewModel</code>值的代码。</p>
<p>此代码属于<code>ViewModel</code>本身，这正是它所起到的作用。</p>
<p>然而有时我们想让一些代码可以在不同的<code>ViewModel</code>中重用。</p>
<p>例如，我们的应用程序中可能有其他<code>View</code>显示日期。这意味着我们需要更多的<code>ViewModel</code>将<code>Date</code>转换为<br>具有特定格式的<code>String</code>。通常在应用程序的所有屏幕上使用相同的数据格式。</p>
<p>所以我们可以将这些代码放在<code>Date Extension</code>中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension Date &#123;</span><br><span class="line">	var day: String &#123;</span><br><span class="line">		let formatter = DateFormatter()</span><br><span class="line">		formatter.dateStyle = .full</span><br><span class="line">		formatter.timeStyle = .none</span><br><span class="line">		return formatter.string(from: self)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	var time: String &#123;</span><br><span class="line">		let formatter = DateFormatter()</span><br><span class="line">		formatter.dateFormat = &quot;HH:mm&quot;</span><br><span class="line">		return formatter.string(from: self)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，我们从<code></code>Date中提取<code>day</code>和<code>time</code>，因为在我们的设计中我们需要分别地使用它们。</p>
<p>同样，<code>duration</code>也有自己的格式。我们需要将用秒来表示的<code>TimeInterval</code>转换成像这样的一个字符串“ 3 小时，10 分钟 ”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">extension TimeInterval &#123;</span><br><span class="line">	var formatted: String &#123;</span><br><span class="line">		let secondsInAnHour = 60 * 60</span><br><span class="line">		let hours = Int(self) / secondsInAnHour</span><br><span class="line">		let minutes = (Int(self) % secondsInAnHour) / 60</span><br><span class="line">		return &quot;\(hours) hours, \(minutes) minutes&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们的设计中，我们还看到时间和机场信息组合在同一条线上。所以我们需要代码将时间，城市和机场名称组合成一个字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extension Endpoint &#123;</span><br><span class="line">	var timeAndAirport: String &#123;</span><br><span class="line">		return date.time</span><br><span class="line">			+ &quot; &quot;</span><br><span class="line">			+ airport.city</span><br><span class="line">			+ &quot;, &quot;</span><br><span class="line">			+ airport.name</span><br><span class="line">			+ &quot; Airport&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我还是将此代码放入<code>Endpoint Extension</code>中，但实际上将它放置在哪里取决于你怎样使用它。</p>
<p>在这里，我假设我们将在我们的应用程序中的其他地方需要它。如果仅在一个<code>View Model</code>中需要此代码，<br>则最好将其放在这个特定的<code>View Model</code>中。</p>
<p>请记住，这些<code>Extension</code>是我们的数据格式化代码的一部分。因此，即使我们扩展了<code>Endpoint</code>结构，<br><strong>此代码也不是<code>Model</code>层的一部分</strong>。</p>
<p>此代码属于<code>View Model</code>层。因此，只有<code>View Model</code>才能使用它。在<code>Model</code>类型中使用这些扩展是一个错误。</p>
<p>如果您想更正式地强制执行此限制，可以将它们声明为<code>fileprivate</code>，这样它们就不会在应用的其他部分中显示出来。<br>但如果您在同一文件中放置了大量<code>View Model</code>，这也并不总是可行的。</p>
<p>最终我们可以编写将<code>Flight</code>转换为<code>ViewModel</code>的完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">extension FlightCardView.ViewModel &#123;</span><br><span class="line">	init(flight: Flight) &#123;</span><br><span class="line">		let departure = flight.departure</span><br><span class="line">		let arrival = flight.arrival</span><br><span class="line">		airportSymbols = departure.airport.symbol + &quot; ➔ &quot; + arrival.airport.symbol</span><br><span class="line">		departureDay = departure.date.day</span><br><span class="line">		departureAirport = departure.timeAndAirport</span><br><span class="line">		airline = flight.airline</span><br><span class="line">		flightNumber = flight.number</span><br><span class="line">		duration = flight.duration.formatted</span><br><span class="line">		arrivalDay = arrival.date.day</span><br><span class="line">		arrivalAirport = arrival.timeAndAirport</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	init() &#123;</span><br><span class="line">		airportSymbols = &quot;&quot;</span><br><span class="line">		departureDay = &quot;&quot;</span><br><span class="line">		departureAirport = &quot;&quot;</span><br><span class="line">		airline = &quot;&quot;</span><br><span class="line">		flightNumber = &quot;&quot;</span><br><span class="line">		duration = &quot;&quot;</span><br><span class="line">		arrivalDay = &quot;&quot;</span><br><span class="line">		arrivalAirport = &quot;&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码接受一个<code>Flight</code>并将其数据转换为<code>FlightCardView</code>所需的各种字符串。</p>
<p>我还添加了一个初始化器来创建一个空<code>ViewModel</code>。这对于重置<code>FlightCardView</code>中<code>UILabel</code>的值很有用。<br>它还有助于从我们的代码中删除<code>optional</code>。</p>
<p>我将这些初始化器放在<code>Extension</code>中，因此我们不会丢失<code>ViewModel</code>结构的默认成员初始化器。这可能对单元测试很有用。</p>
<p>我们现在需要的是将<code>ViewModel</code>传递给<code>FlightCardView</code>的一种方法。 </p>
<p>我们可以通过一个观察属性<code>viewModel</code>来执行此操作，在每次设置新的<code>viewModel</code>时自动更新<code>UILabel</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class FlightCardView: UIView &#123;</span><br><span class="line">	@IBOutlet private weak var airportSymbolsLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var departureDayLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var departureAirportLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var airlineLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var flightNumberLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var durationLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var arrivalDayLabel: UILabel!</span><br><span class="line">	@IBOutlet private weak var arrivalAirportLabel: UILabel!</span><br><span class="line">	</span><br><span class="line">	var viewModel: ViewModel = ViewModel() &#123;</span><br><span class="line">		didSet &#123;</span><br><span class="line">			airportSymbolsLabel.text = viewModel.airportSymbols</span><br><span class="line">			departureDayLabel.text = viewModel.departureDay</span><br><span class="line">			departureAirportLabel.text = viewModel.departureAirport</span><br><span class="line">			airlineLabel.text = viewModel.airline</span><br><span class="line">			flightNumberLabel.text = viewModel.flightNumber</span><br><span class="line">			durationLabel.text = viewModel.duration</span><br><span class="line">			arrivalDayLabel.text = viewModel.arrivalDay</span><br><span class="line">			arrivalAirportLabel.text = viewModel.arrivalAirport</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将来，我们还可以使用此<code>View</code>显示除<code>Flight</code>结构之外的数据。我们需要做的只是为<code>ViewModel</code>添加一个新的初始化器。</p>
<p>没有其他代码会改变，<code>FlightCardView</code>不会，<code>Flight</code>的结构也不会，甚至<code>ViewModel</code>结构都不会改变。</p>
<h3 id="View-Controller负责从Model到View的数据流"><a href="#View-Controller负责从Model到View的数据流" class="headerlink" title="View Controller负责从Model到View的数据流"></a><code>View Controller</code>负责从<code>Model</code>到<code>View</code>的数据流</h3><p>我们现在需要组合我们的应用程序，以在屏幕上显示一些信息。</p>
<p>正如<code>MVC</code>所规定的那样，<code>View Controller</code>传递数据流</p>
<p>首先，我们需要一些实际数据来显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private extension FlightInfoViewController &#123;</span><br><span class="line">	func createFlight() -&gt; Flight &#123;</span><br><span class="line">		return Flight(</span><br><span class="line">			airline: &quot;Aeroflot&quot;,</span><br><span class="line">			number: &quot;AF 3245&quot;,</span><br><span class="line">			departure: Endpoint(</span><br><span class="line">				date: Date(),</span><br><span class="line">				airport: Airport(symbol: &quot;AMS&quot;, name: &quot;Schipol&quot;, city: &quot;Amsterdam&quot;)</span><br><span class="line">			),</span><br><span class="line">			arrival: Endpoint(</span><br><span class="line">				date: Date().addingTimeInterval(3 * 60 * 60 + 10 * 60),</span><br><span class="line">				airport: Airport(symbol: &quot;SVO&quot;, name: &quot;Sheremetyevo&quot;, city: &quot;Moscow&quot;)</span><br><span class="line">			)</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，为了方便起见，我在<code>View Controller</code>中创建了此数据，但这不是正确的位置。<a href="http://matteomanferdini.com/how-to-persist-data-in-ios-apps-using-property-lists-and-the-correct-architecture-for-handling-persistent-storage/" target="_blank" rel="noopener">数据应来自<code>Model Controller</code></a>，<br>从磁盘或网络检索数据的代码通常驻留在<code>Model Controller</code>中。</p>
<p>现在<code>View Controller</code>所有需要做的是初始化<code>ViewModel</code>并将其传递给它的<code>FlightCardView</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class FlightInfoViewController: UIViewController &#123;</span><br><span class="line">	@IBOutlet private weak var cardView: FlightCardView!</span><br><span class="line">	</span><br><span class="line">	override func viewDidLoad() &#123;</span><br><span class="line">		super.viewDidLoad()</span><br><span class="line">		let flight = createFlight()</span><br><span class="line">		cardView.viewModel = FlightCardView.ViewModel(flight: flight)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，在我们编写的所有代码中，只有2行属于<code>View Controller</code>。</p>
<p>与您通常在<code>iOS</code>应用中看到的<code>Massive View Controller</code>完全不同。</p>
<p><a href="https://github.com/matteom/FlightInfo" target="_blank" rel="noopener">您可以在<code>GitHub</code>上找到此示例的完整代码</a>。</p>
<h3 id="惰性View-Model的优点"><a href="#惰性View-Model的优点" class="headerlink" title="惰性View Model的优点"></a>惰性<code>View Model</code>的优点</h3><p>正如您所看到的，惰性<code>View Model</code>的优点很多：</p>
<ul>
<li>我们尊重<code>MVC</code>的结构和职责划分</li>
<li><code>View</code>和数据完全脱离开</li>
<li>无法访问特定视图的内部实现</li>
<li><code>View Controller</code>具有更少的职责和较少的代码</li>
<li><code>View</code>可以跨屏幕甚至跨项目重复使用</li>
<li>扩展<code>View Model</code>有助于为完全不同类型的数据重用相同的<code>View</code></li>
<li><code>View Model</code>代码是容易测试的，而无需像<code>mock</code>那样测试两次</li>
</ul>
<p>原文地址：<a href="https://matteomanferdini.com/mvvm-pattern-ios-swift/" target="_blank" rel="noopener">https://matteomanferdini.com/mvvm-pattern-ios-swift/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">pragmatic	实用主义  </span><br><span class="line">approach 接近,方法  </span><br><span class="line">controversy 论战  </span><br><span class="line">shortcoming 缺点  </span><br><span class="line">definitely 肯定的  </span><br><span class="line">functional 有用的，实用的  </span><br><span class="line">concrete 实在的，具体的，混泥土  </span><br><span class="line">violate 违反，违背  </span><br><span class="line">interpret 解释，说明，翻译  </span><br><span class="line">dictate 指示，指定，指令</span><br><span class="line">extensively 广大地</span><br><span class="line">discern 区分，辨别</span><br><span class="line">trivial 不重要的，琐碎的</span><br><span class="line">populate 居住于，构成人口</span><br><span class="line">explicitly 明白地,明确地</span><br><span class="line">optimal 最理想的，最佳的</span><br><span class="line">impact 影响，冲击</span><br><span class="line">derive 源于，得到</span><br><span class="line">aim 针对，以···为目标</span><br><span class="line">accurate 精准的，准确的</span><br><span class="line">vocal 口头的</span><br><span class="line">proponent 支持者，拥护者</span><br><span class="line">roundup 综述，集拢</span><br><span class="line">skeptical 怀疑性的</span><br><span class="line">implication 影响</span><br><span class="line">downside 下降趋势，缺点</span><br><span class="line">inherently 天性地,固有地</span><br><span class="line">problematic 成问题的，有疑问的</span><br><span class="line">contemplate 深思, 细想</span><br><span class="line">intricate 错综复杂的</span><br><span class="line">can of worms 会造成更多问题</span><br><span class="line">pandora&apos;s box 潘多拉盒子,灾难之源</span><br><span class="line">paradigm 范例</span><br><span class="line">incidentally 偶然地, 不经意地</span><br><span class="line">beast 野兽</span><br><span class="line">illustrate 说明, 阐明</span><br><span class="line">concept 概念，观念</span><br><span class="line">disjoint 解体，使脱臼</span><br><span class="line">hierarchy 等级制度</span><br><span class="line">visualize 形象化, 设想</span><br><span class="line">sole  唯一的，仅有的</span><br><span class="line">separately 分别地，个别地</span><br><span class="line">restriction 约束，限制</span><br><span class="line">reside 居住，定居</span><br></pre></td></tr></table></figure>

        </div>
        
<blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2018-09-28T03:34:44.000Z" itemprop="dateUpdated">2018-09-28 11:34:44</time>
</span><br>


        
        转载注明出处，原文地址：<a href="/2016/06/18/MVVM模式/" target="_blank" rel="external">http://http://ioshc.github.io/2016/06/18/MVVM模式/</a>
        
    </div>
    <footer>
        <a href="http://http://ioshc.github.io">
            <img src="/img/avatar.jpg" alt="Eden Huang">
            Eden Huang
        </a>
    </footer>
</blockquote>

        
            <div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>

            
        
        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MVVM/">MVVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

            <div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://http://ioshc.github.io/2016/06/18/MVVM模式/&title=《Swift中iOS应用程序的MVVM模式》 — Hello World&pic=http://http://ioshc.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://http://ioshc.github.io/2016/06/18/MVVM模式/&title=《Swift中iOS应用程序的MVVM模式》 — Hello World&source=任何描述都是多余的" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>

        </div>
        
            


        
    </div>
    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="prev">
      <a href="/2017/07/25/iOS代码规范/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">iOS代码规范</h4>
      </a>
    </div>
  

  
    <div class="next">
      <a href="/2016/05/20/markdown基本语法/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">markdown基本语法</h4>
      </a>
    </div>
  
</nav>


    
    
        <aside class="post-widget">
            <nav class="post-toc-wrap" id="post-toc">
                <strong>目录</strong>
                <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Swift中iOS应用程序的MVVM模式：一个实用的方法"><span class="post-toc-number">1.</span> <span class="post-toc-text">Swift中iOS应用程序的MVVM模式：一个实用的方法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在MVC模式中，View不应该知道相关App中Model的任何信息"><span class="post-toc-number">2.</span> <span class="post-toc-text">在MVC模式中，View不应该知道相关App中Model的任何信息</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Model类型和View之间的桥接有其自身的问题"><span class="post-toc-number">3.</span> <span class="post-toc-text">Model类型和View之间的桥接有其自身的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#View不应该暴露其内部实现"><span class="post-toc-number">4.</span> <span class="post-toc-text">View不应该暴露其内部实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在View-Controller中做数据转换不是最优的"><span class="post-toc-number">5.</span> <span class="post-toc-text">在View Controller中做数据转换不是最优的</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MVVM模式是MVC模式的扩展"><span class="post-toc-number">6.</span> <span class="post-toc-text">MVVM模式是MVC模式的扩展</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#View-Model应该是值类型，而不是引用类型"><span class="post-toc-number">7.</span> <span class="post-toc-text">View Model应该是值类型，而不是引用类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#网络代码不应该进入View-Model"><span class="post-toc-number">8.</span> <span class="post-toc-text">网络代码不应该进入View Model</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#函数响应式编程框架隐藏了幕后的大量复杂性"><span class="post-toc-number">9.</span> <span class="post-toc-text">函数响应式编程框架隐藏了幕后的大量复杂性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#View-Model作为惰性值类型"><span class="post-toc-number">10.</span> <span class="post-toc-text">View Model作为惰性值类型</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MVVM的基本块是自定义视图"><span class="post-toc-number">11.</span> <span class="post-toc-text">MVVM的基本块是自定义视图</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#View不需要关心Model类型的结构"><span class="post-toc-number">12.</span> <span class="post-toc-text">View不需要关心Model类型的结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#View-Model以最终格式向View提供数据"><span class="post-toc-number">13.</span> <span class="post-toc-text">View Model以最终格式向View提供数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#将数据类型中的数据转换为View-Model的格式"><span class="post-toc-number">14.</span> <span class="post-toc-text">将数据类型中的数据转换为View Model的格式</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#View-Controller负责从Model到View的数据流"><span class="post-toc-number">15.</span> <span class="post-toc-text">View Controller负责从Model到View的数据流</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#惰性View-Model的优点"><span class="post-toc-number">16.</span> <span class="post-toc-text">惰性View Model的优点</span></a></li></ol>
            </nav>
            <div class="toc-bar"><div>
        </aside>
    
</article>

    <div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        我们一起来让这个世界有趣一点
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/reward-wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/reward-wechat.jpg" data-alipay="/img/reward-alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>

    
</div>

        <footer class="footer">
    
    <div class="top">
        
    </div>
    
    <div class="bottom">
        <p>
            <span>
                Eden Huang &copy; 2018
            </span>
        		
           	
            
            
            <span>
	            Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/codefine/hexo-theme-mellow" target="_blank">mellow</a>
            </span>
            
            
            

            
                
<span class="site-uv" title="总访客量">
    <i class="icon icon-user"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_uv"></i>
</span>


<span class="site-pv" title="总访问量">
    <i class="icon icon-eye"></i>
    <i class="busuanzi-value" id="busuanzi_value_site_pv"></i>
</span>

            
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://http://ioshc.github.io/2016/06/18/MVVM模式/&title=《Swift中iOS应用程序的MVVM模式》 — Hello World&pic=http://http://ioshc.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://http://ioshc.github.io/2016/06/18/MVVM模式/&title=《Swift中iOS应用程序的MVVM模式》 — Hello World&source=任何描述都是多余的" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACL0lEQVR42u3aW66CUAwFUOc/ae4AjLDb6k0o63wZo8Lio/b1esXneDvv759/8vw3399//eJgYGDclnGcnvNL9q7Se0wXDwgDA+MBjE8/nbzugT+F2k/XurhnDAwMjNME7vzyhaAZXBcDAwNjwsi/lRwMDAyMXhE7KV8nr79ci2NgYNyQ8T+3MgnTX55vYGBg3IpxFE9vGFltwJXvCgMDYzUjD3BJQ20+TpjcDwYGxm5GNSlM1rnyoWZ15PC13BYDA+MmjOooMR9Vfut3omthYGCsZlTLyDxZzAN0stKa/BlgYGBsZUxWtfJBY85rfhcDA2M1o1q4VlfHeuzC/0Ov/sbAwLghY57kJYVoL8XMxwkYGBhbGeetsZxUeGatZYuoa4iBgfEARq9Ll5eveRlcDvoYGBirGcnoMV+2yMvOQstsUsRiYGCsYOQJ3KSJ33tYhYIWAwNjNaO3vJV/clKsNlcxMDAw1jGqKVpvjewYnCitxMDAWM2Yr3n9oj3XSzExMDCeyUjCXHUJYzIYuOitYWBgPIzRW30o76MNAnGUGmJgYCxllEvHeKWsuthRnldiYGAsZfSaX5NWWq+Fd1EwY2BgrGb0BgDVIFtNFntJJwYGxm7GPMhORpW9gHsxGMDAwFjKyKveavAtt/hbiSMGBgZGElirA8tJ0hltdmBgYDye0Wu95eG4upyBgYHxBEa+3JAvT0zGn/lvYmBgPIFRXXGYDCB7Q8156YuBgXFbxh8fljf1t0J5FAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>


    
    <!-- main-js -->
<script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.0/jquery.min.js"></script>
<script type="text/javascript" src="/js/plugins/fastclick.js?v=1.3.2"></script>
<script type="text/javascript" src="/js/plugins/ios-orientationchange-fix.js?v=1.3.2"></script>
<script type="text/javascript" src="/js/plugins/jquery.swipebox.min.js?v=1.3.2"></script>

<script type="text/javascript" src="https://cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script type="text/javascript" src="/js/method.js?v=1.3.2"></script>
<script type="text/javascript" src="/js/blog.js?v=1.3.2"></script>

<!-- third-party -->
<script type="text/javascript">
;( function( $ ) {

	$( '.swipebox' ).swipebox({
		hideCloseButtonOnMobile: true
	});

} )( jQuery );
</script>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?[object Object]";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<script type="text/javascript" src="/js/plugins/local_search.js?v=1.3.2"></script>
<script type="text/javascript">
	var search_path = "search.xml";
	if (search_path.length === 0) {
		search_path = "search.xml";
	}
	var path = "/" + search_path;
	searchFunc(path, "local-search-input", "local-search-result");
</script>



<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



    
    





    <!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>






    
</body>
</html>
